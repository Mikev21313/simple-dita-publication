name: DITA to SPA with Complete Supabase Review System

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Set up Java (required for DITA-OT)
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Step 3: Install DITA-OT and required tools
      - name: Set up DITA-OT and XML tools
        run: |
          sudo apt-get update
          sudo apt-get install -y libxml2-utils xsltproc postgresql-client

          # Install DITA-OT
          wget https://github.com/dita-ot/dita-ot/releases/download/4.0.2/dita-ot-4.0.2.zip
          unzip dita-ot-4.0.2.zip
          chmod +x dita-ot-4.0.2/bin/dita

      # Step 4: Setup Supabase Database with Correct Schema
      - name: Setup Supabase Database Schema
        run: |
          echo "Setting up Supabase database schema..."
          export PGPASSWORD="${{ secrets.SUPABASE_DB_PASSWORD }}"
          
          # Create comprehensive schema SQL
          cat > schema.sql << 'EOF'
          -- Drop existing tables if they exist (for clean rebuild)
          DROP TABLE IF EXISTS uploaded_images CASCADE;
          DROP TABLE IF EXISTS comments CASCADE;

          -- Create comments table with correct structure
          CREATE TABLE comments (
            id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
            page_id TEXT NOT NULL,
            comment_type TEXT NOT NULL CHECK (comment_type IN ('comment', 'suggestion')),
            comment_text TEXT,
            selected_text TEXT,
            selection_type TEXT CHECK (selection_type IN ('text', 'image')),
            image_src TEXT,
            image_alt TEXT,
            position_x DECIMAL,
            position_y DECIMAL,
            resolved BOOLEAN DEFAULT FALSE,
            resolved_timestamp TIMESTAMPTZ,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ DEFAULT NOW(),
            session_id TEXT,
            user_agent TEXT
          );

          -- Create uploaded_images table
          CREATE TABLE uploaded_images (
            id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
            comment_id UUID REFERENCES comments(id) ON DELETE CASCADE,
            filename TEXT NOT NULL,
            file_data TEXT NOT NULL,
            file_size INTEGER,
            file_type TEXT,
            created_at TIMESTAMPTZ DEFAULT NOW()
          );

          -- Create indexes for performance
          CREATE INDEX idx_comments_page_id ON comments(page_id);
          CREATE INDEX idx_comments_created_at ON comments(created_at);
          CREATE INDEX idx_comments_resolved ON comments(resolved);
          CREATE INDEX idx_uploaded_images_comment_id ON uploaded_images(comment_id);

          -- Disable RLS for easier access (enable later if needed)
          ALTER TABLE comments DISABLE ROW LEVEL SECURITY;
          ALTER TABLE uploaded_images DISABLE ROW LEVEL SECURITY;

          -- Grant permissions to anon user
          GRANT ALL ON comments TO anon;
          GRANT ALL ON uploaded_images TO anon;
          GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO anon;

          -- Create trigger function for updated_at
          CREATE OR REPLACE FUNCTION update_updated_at_column()
          RETURNS TRIGGER AS $$
          BEGIN
            NEW.updated_at = NOW();
            RETURN NEW;
          END;
          $$ language 'plpgsql';

          -- Create trigger
          CREATE TRIGGER update_comments_updated_at BEFORE UPDATE ON comments
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
          EOF
          
          # Apply schema using psql
          psql "postgresql://postgres:${{ secrets.SUPABASE_DB_PASSWORD }}@db.oiluavgeyngmkqozzmnz.supabase.co:5432/postgres" -f schema.sql
          
          echo "Database schema setup completed successfully"

      # Step 5: Parse DITAMAP to generate navigation structure
      - name: Parse DITAMAP Structure
        run: |
          echo "Parsing DITAMAP structure from dita-source/automotive.ditamap"

          # Create XSLT file for navigation extraction
          cat > extract-nav.xsl << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:output method="text"/>
            <xsl:template match="/">
              [<xsl:apply-templates select="//topicref[not(ancestor::topicref)]"/>]
            </xsl:template>
            <xsl:template match="topicref">
              <xsl:variable name="href" select="@href"/>
              <xsl:variable name="filename">
                <xsl:choose>
                  <xsl:when test="contains($href, '/')">
                    <xsl:value-of select="substring-after(substring-before($href, '.'), '/')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="substring-before($href, '.')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="id">
                <xsl:choose>
                  <xsl:when test="@id"><xsl:value-of select="@id"/></xsl:when>
                  <xsl:otherwise><xsl:value-of select="translate($filename, '_', '-')"/></xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="title">
                <xsl:choose>
                  <xsl:when test="@navtitle"><xsl:value-of select="@navtitle"/></xsl:when>
                  <xsl:when test="topicmeta/navtitle"><xsl:value-of select="topicmeta/navtitle"/></xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="translate(translate($id, '-', ' '), '_', ' ')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              {
                "id": "<xsl:value-of select="$id"/>",
                "title": "<xsl:value-of select="$title"/>",
                "filename": "<xsl:value-of select="$filename"/>",
                "href": "<xsl:value-of select="$href"/>"
                <xsl:if test="topicref">
                  ,"children": [<xsl:apply-templates select="topicref"/>]
                </xsl:if>
              }<xsl:if test="following-sibling::topicref">,</xsl:if>
            </xsl:template>
          </xsl:stylesheet>
          EOF

          # Apply XSLT transformation
          xsltproc extract-nav.xsl dita-source/automotive.ditamap > navigation-structure.json || echo "[]" > navigation-structure.json
          sed -i 's/\\n//g; s/\\t//g; s/  / /g' navigation-structure.json

          echo "DITAMAP parsing complete"
          cat navigation-structure.json

      # Step 6: Transform DITA to HTML
      - name: Transform DITA to HTML and Prepare Images
        run: |
          ./dita-ot-4.0.2/bin/dita --input=dita-source/automotive.ditamap --format=html5 --output=./site || echo "DITA transformation completed"
          
          mkdir -p ./site/content ./site/images ./site/js ./site/css

          # Copy images
          find ./dita-source -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.svg" \) -exec cp -v {} ./site/images/ \; || echo "No images found"

          # Create placeholder if no images
          if [ ! "$(ls -A ./site/images 2>/dev/null)" ]; then
            echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" | base64 -d > ./site/images/placeholder.png
          fi

      # Step 7: Process HTML content for SPA
      - name: Process HTML Content
        run: |
          # Process HTML files to create SPA content
          find ./site -type f -name "*.html" | grep -v "index.html" | grep -v "404.html" | while read file; do
            if [[ "$file" == "./site/index.html" ]]; then continue; fi

            filename=$(basename "$file")
            id="${filename%.html}"
            hyphenated_id="${id//_/-}"

            # Extract content
            content=$(sed -n '/<body/,/<\/body>/p' "$file" | sed '/<body/d;/<\/body>/d' | sed '/<header/,/<\/header>/d' | sed '/<nav/,/<\/nav>/d' | sed '/<footer/,/<\/footer>/d')
            
            # Fix image paths
            content=$(echo "$content" | sed -E 's/<img([^>]*)src="[^"]*\/([^\/"]*)\.([a-zA-Z0-9]+)"/<img\1src="images\/\2.\3"/gi')
            content=$(echo "$content" | sed -E 's/<img([^>]*)src="([^\/:"]*)\.(jpg|jpeg|png|gif|svg)"/<img\1src="images\/\2.\3"/gi')

            # Get title
            title=$(grep -o "<title>.*</title>" "$file" | sed 's/<title>\(.*\)<\/title>/\1/' | head -1)
            if [ -z "$title" ]; then
              title=$(echo "$id" | tr '_-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')
            fi

            # Create content files
            echo "$content" > "./site/content/$id.html"
            if [[ "$id" != "$hyphenated_id" ]]; then
              echo "$content" > "./site/content/$hyphenated_id.html"
            fi
          done

          # Create content ID mapping
          echo "// Auto-generated content ID mapping" > ./site/js/content-id-map.js
          echo "const contentIdMap = {" >> ./site/js/content-id-map.js

          find ./site -type f -name "*.html" | grep -v "index.html" | grep -v "404.html" | while read file; do
            filename=$(basename "$file" .html)
            id="${filename//_/-}"
            original_filename="$filename"
            title=$(grep -o "<title>.*</title>" "$file" | sed 's/<title>\(.*\)<\/title>/\1/' | head -1)
            raw_content=$(cat "$file" | tr '\n' ' ' | sed 's/<[^>]*>//g' | sed 's/&nbsp;/ /g' | sed 's/  */ /g' | tr -d '\n\r')

            if grep -q "\"$id\":" ./site/js/content-id-map.js; then continue; fi

            if [ -z "$title" ]; then
              title=$(echo "$id" | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')
            fi

            title=$(echo "$title" | sed 's/"/\\"/g')
            raw_content=$(echo "$raw_content" | sed 's/"/\\"/g')

            echo "  \"$id\": { \"title\": \"$title\", \"filename\": \"$original_filename\", \"content\": \"$raw_content\" }," >> ./site/js/content-id-map.js
          done

          echo "  \"default\": { \"title\": \"Automotive Documentation\", \"filename\": \"\", \"content\": \"\" }" >> ./site/js/content-id-map.js
          echo "};" >> ./site/js/content-id-map.js

      # Step 8: Generate Navigation Configuration
      - name: Generate Navigation Configuration
        run: |
          cat > ./site/js/navigation-config.js << 'EOF'
          // Auto-generated navigation structure from DITAMAP
          const navigationConfig =
          EOF
          cat ./navigation-structure.json >> ./site/js/navigation-config.js
          echo ";" >> ./site/js/navigation-config.js

      # Step 9: Create Supabase Configuration with Correct Keys
      - name: Create Supabase Configuration
        run: |
          cat > ./site/js/supabase-config.js << 'EOF'
          // Supabase configuration with verified keys
          const SUPABASE_URL = 'https://oiluavgeyngmkqozzmnz.supabase.co';
          const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9pbHVhdmdleW5nbWtxb3p6bW56Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0NjIxOTgsImV4cCI6MjA2NDAzODE5OH0.zsfYoYDgArOBjP7SziUMgRQpIHhwTb-qgtw7t54MsXQ';

          // Supabase client class
          class SupabaseClient {
            constructor() {
              this.baseUrl = SUPABASE_URL;
              this.headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'apikey': SUPABASE_ANON_KEY
              };
            }

            async request(endpoint, options = {}) {
              const url = `${this.baseUrl}/rest/v1/${endpoint}`;
              const config = { headers: this.headers, ...options };

              try {
                const response = await fetch(url, config);
                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
              } catch (error) {
                console.error('Supabase request failed:', error);
                throw error;
              }
            }

            async getComments(pageId) {
              try {
                const comments = await this.request(`comments?page_id=eq.${encodeURIComponent(pageId)}&order=created_at.desc`);
                const commentsWithImages = await Promise.all(
                  comments.map(async (comment) => {
                    const images = await this.request(`uploaded_images?comment_id=eq.${comment.id}`);
                    return {
                      ...comment,
                      uploadedImages: images.map(img => ({
                        id: img.id,
                        name: img.filename,
                        data: img.file_data,
                        size: img.file_size,
                        type: img.file_type
                      }))
                    };
                  })
                );
                return commentsWithImages;
              } catch (error) {
                console.error('Failed to fetch comments:', error);
                return [];
              }
            }

            async saveComment(commentData) {
              try {
                const comment = {
                  page_id: commentData.page_id,
                  comment_type: commentData.comment_type,
                  comment_text: commentData.comment_text,
                  selected_text: commentData.selected_text,
                  selection_type: commentData.selection_type || 'text',
                  session_id: this.getSessionId(),
                  user_agent: navigator.userAgent
                };

                const response = await fetch(`${this.baseUrl}/rest/v1/comments`, {
                  method: 'POST',
                  headers: this.headers,
                  body: JSON.stringify(comment)
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                return await response.json();
              } catch (error) {
                console.error('Failed to save comment:', error);
                throw error;
              }
            }

            async updateComment(commentId, updates) {
              try {
                const response = await fetch(`${this.baseUrl}/rest/v1/comments?id=eq.${commentId}`, {
                  method: 'PATCH',
                  headers: this.headers,
                  body: JSON.stringify(updates)
                });

                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
                }

                return await response.json();
              } catch (error) {
                console.error('Failed to update comment:', error);
                throw error;
              }
            }

            async clearAllComments() {
              try {
                await fetch(`${this.baseUrl}/rest/v1/uploaded_images`, {
                  method: 'DELETE',
                  headers: this.headers
                });
                await fetch(`${this.baseUrl}/rest/v1/comments`, {
                  method: 'DELETE',
                  headers: this.headers
                });
                return true;
              } catch (error) {
                console.error('Failed to clear comments:', error);
                throw error;
              }
            }

            getSessionId() {
              let sessionId = localStorage.getItem('reviewSessionId');
              if (!sessionId) {
                sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('reviewSessionId', sessionId);
              }
              return sessionId;
            }
          }

          // Initialize client
          window.supabaseClient = new SupabaseClient();
          EOF

      # Step 10: Create Enhanced CSS with Review System Styles
      - name: Create Enhanced CSS
        run: |
          cat > ./site/css/style.css << 'EOF'
          /* Enhanced SPA CSS with Complete Review System */
          * { margin: 0; padding: 0; box-sizing: border-box; }

          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6; display: flex; height: 100vh; width: 100%;
            overflow: hidden; color: #333; background-color: #f8f8f8;
          }

          .sidebar {
            width: 280px; background-color: #e0f7f7; padding: 15px;
            height: 100vh; overflow-y: auto; border-right: 1px solid #c0e0e0;
            display: flex; flex-direction: column; box-shadow: 2px 0 5px rgba(0,0,0,0.05);
          }

          .main-content {
            flex: 1; padding: 30px; height: 100vh; overflow-y: auto;
            background-color: #ffffff; position: relative;
          }

          .sidebar h2 {
            font-weight: 500; margin-bottom: 15px; color: #00747a;
            border-bottom: 2px solid #80cbc4; padding-bottom: 10px; font-size: 1.4em;
          }

          .sidebar-nav { flex: 1; overflow-y: auto; margin-top: 15px; }
          .sidebar ul { list-style-type: none; padding-left: 0; margin-bottom: 5px; }
          .sidebar ul ul { padding-left: 20px; margin-top: 5px; margin-bottom: 0; }
          .sidebar li { margin-bottom: 6px; position: relative; }

          .sidebar .toggle-arrow {
            display: inline-block; width: 18px; height: 18px;
            position: absolute; left: 0; top: 4px; cursor: pointer;
            z-index: 10; color: #00747a;
          }
          .sidebar .toggle-arrow:before {
            content: "â–¶"; display: inline-block; font-size: 10px;
            transition: transform 0.2s;
          }
          .sidebar li.expanded > .toggle-arrow:before { transform: rotate(90deg); }
          .sidebar li.has-children > ul { display: none; }
          .sidebar li.has-children.expanded > ul { display: block; }

          .sidebar a {
            color: #00747a; text-decoration: none; display: block;
            padding: 6px 5px 6px 22px; border-radius: 4px;
            transition: background-color 0.2s, color 0.2s; cursor: pointer; font-size: 0.95em;
          }
          .sidebar a:hover { background-color: #e1f5fe; color: #006064; }
          .sidebar a.active {
            background-color: #80deea; font-weight: bold; color: #006064;
            box-shadow: inset 3px 0 0 #00acc1;
          }

          .review-controls {
            border-top: 2px solid #80cbc4; padding-top: 15px; margin-top: 15px;
            display: flex; flex-direction: column; gap: 10px;
          }
          .review-controls h3 { color: #00747a; font-size: 1.1em; margin-bottom: 10px; }

          .review-btn {
            padding: 8px 12px; border: 1px solid #00acc1;
            background: linear-gradient(135deg, #00acc1, #0097a7); color: white;
            border-radius: 5px; cursor: pointer; font-size: 0.9em;
            transition: all 0.3s; text-align: center;
          }
          .review-btn:hover {
            background: linear-gradient(135deg, #0097a7, #00838f);
            transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.2);
          }
          .review-btn.active {
            background: linear-gradient(135deg, #ff6f00, #e65100); border-color: #ff6f00;
          }
          .review-btn.secondary {
            background: linear-gradient(135deg, #546e7a, #455a64); border-color: #546e7a;
            font-size: 0.85em; padding: 6px 10px;
          }
          .review-btn.danger {
            background: linear-gradient(135deg, #f44336, #d32f2f); border-color: #f44336;
            font-size: 0.85em; padding: 6px 10px;
          }

          .search-container {
            margin-bottom: 15px; display: flex; gap: 5px; width: 100%;
          }
          .search-container input[type="text"] {
            flex-grow: 1; padding: 8px 10px; border: 1px solid #b0e0e6;
            border-radius: 5px; font-size: 0.9em; outline: none;
          }
          .search-container button {
            padding: 8px 10px; background-color: #00acc1; color: white;
            border: none; border-radius: 5px; cursor: pointer;
          }

          .search-results {
            list-style-type: none; padding: 0; margin-top: 15px;
            border-top: 1px solid #e0e0e0; padding-top: 10px;
            max-height: 300px; overflow-y: auto; background-color: #f5f9f9;
          }

          .main-content h1, .main-content h2, .main-content h3, .main-content h4 {
            font-weight: 500; margin-top: 1.5em; margin-bottom: 0.8em; color: #00838f;
          }
          .main-content h1 {
            font-size: 2em; border-bottom: 1px solid #e0e0e0;
            padding-bottom: 10px; margin-top: 0;
          }
          .main-content p { margin-bottom: 1em; line-height: 1.6; }
          .main-content img {
            max-width: 100%; height: auto; display: block; margin: 1em auto;
            border: 1px solid #e0e0e0; border-radius: 4px;
          }

          .welcome-screen {
            text-align: center; padding: 40px 20px; color: #00838f;
          }
          .welcome-screen h2 { margin-bottom: 20px; font-size: 2em; }

          .connection-status {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            padding: 8px 16px; border-radius: 4px; font-size: 0.8em;
            font-weight: bold; z-index: 2000; transition: all 0.3s;
          }
          .connection-status.connected { background: #4caf50; color: white; }
          .connection-status.disconnected { background: #f44336; color: white; }
          .connection-status.hidden { opacity: 0; pointer-events: none; }

          /* Review Mode Styles */
          .review-mode .main-content { background-color: #fffbf0; }
          .review-mode .reviewable-text { cursor: text; user-select: text; }

          .review-comment-highlight {
            background-color: #e1f5fe; border-left: 3px solid #2196f3;
            padding: 2px 4px; margin: 2px 0; border-radius: 2px; cursor: pointer;
          }
          .review-suggestion-highlight {
            background-color: #fff3e0; border-left: 3px solid #ff9800;
            padding: 2px 4px; margin: 2px 0; border-radius: 2px; cursor: pointer;
          }

          /* Comment Dialog */
          .dialog-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.5); z-index: 1999; display: none;
          }
          .dialog-overlay.show { display: block; }

          .comment-dialog {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; border: 2px solid #2c5aa0; border-radius: 8px;
            padding: 20px; width: 450px; max-width: 90vw; z-index: 2000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); display: none;
          }
          .comment-dialog.show { display: block; }
          .comment-dialog h3 { color: #2c5aa0; margin-bottom: 15px; }
          .comment-dialog textarea {
            width: 100%; height: 100px; padding: 10px; border: 1px solid #ddd;
            border-radius: 4px; font-family: inherit; resize: vertical;
          }

          .dialog-actions {
            display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;
          }
          .dialog-btn {
            padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px;
            cursor: pointer; font-size: 0.9em; transition: all 0.2s;
          }
          .dialog-btn.primary {
            background: #2c5aa0; color: white; border-color: #2c5aa0;
          }
          .dialog-btn.secondary { background: #f5f5f5; }

          /* Responsive */
          @media (max-width: 768px) {
            body { flex-direction: column; height: auto; }
            .sidebar { width: 100%; height: auto; max-height: 40vh; }
            .main-content { height: auto; min-height: 60vh; }
          }
          EOF

      # Step 11: Create Complete SPA JavaScript with Full Review System
      - name: Create Complete SPA JavaScript with Review System
        run: |
          cat > ./site/js/app.js << 'EOF'
          // Complete SPA Application with Full Review System

          // DOM Elements
          const contentEl = document.getElementById('content');
          const contentTitleEl = document.getElementById('content-title');
          const navigationEl = document.getElementById('navigation');
          const searchInput = document.getElementById('searchInput');
          const searchButton = document.getElementById('searchButton');
          const searchResultsEl = document.getElementById('searchResults');
          const reviewToggleBtn = document.getElementById('reviewToggle');
          const startReviewBtn = document.getElementById('startReview');
          const clearReviewBtn = document.getElementById('clearReview');

          // State
          const getBasePath = () => {
            if (location.hostname.includes('github.io')) {
              const pathSegments = location.pathname.split('/');
              if (pathSegments.length > 1) return '/' + pathSegments[1];
            }
            return '';
          };

          window.currentPage = null;
          window.reviewMode = false;
          window.reviewData = {};
          window.currentSelection = null;
          const basePath = getBasePath();
          let connectionStatus = 'connected';

          function debug(message, data) {
            console.log(`[DITA-SPA] ${message}`, data || '');
          }

          // Connection Status
          function showConnectionStatus(status, message) {
            let statusEl = document.getElementById('connectionStatus');
            if (!statusEl) {
              statusEl = document.createElement('div');
              statusEl.id = 'connectionStatus';
              statusEl.className = 'connection-status';
              document.body.appendChild(statusEl);
            }
            statusEl.className = `connection-status ${status}`;
            statusEl.textContent = message;
            if (status === 'connected') {
              setTimeout(() => statusEl.classList.add('hidden'), 3000);
            } else {
              statusEl.classList.remove('hidden');
            }
          }

          // Test Supabase Connection
          async function testSupabaseConnection() {
            try {
              const response = await fetch('https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/comments?limit=1', {
                headers: {
                  'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9pbHVhdmdleW5nbWtxb3p6bW56Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0NjIxOTgsImV4cCI6MjA2NDAzODE5OH0.zsfYoYDgArOBjP7SziUMgRQpIHhwTb-qgtw7t54MsXQ',
                  'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9pbHVhdmdleW5nbWtxb3p6bW56Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0NjIxOTgsImV4cCI6MjA2NDAzODE5OH0.zsfYoYDgArOBjP7SziUMgRQpIHhwTb-qgtw7t54MsXQ',
                  'Content-Type': 'application/json'
                }
              });
              
              if (response.ok) {
                connectionStatus = 'connected';
                showConnectionStatus('connected', 'ðŸŸ¢ Connected to Supabase');
                debug('Supabase connection successful');
              } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
            } catch (error) {
              connectionStatus = 'disconnected';
              showConnectionStatus('disconnected', 'ðŸ”´ Database connection failed');
              debug('Supabase connection failed:', error);
            }
          }

          // Initialize App
          function initApp() {
            debug('Initializing app with base path:', basePath);
            testSupabaseConnection();
            renderNavigation(navigationConfig);
            setupEventListeners();
            initReviewSystem();

            const initialPageId = getPageIdFromUrl();
            if (initialPageId) {
              navigateToPage(initialPageId, false);
            } else {
              showWelcomeScreen();
            }
          }

          // Event Listeners
          function setupEventListeners() {
            window.addEventListener('popstate', handlePopState);
            
            if (searchButton && searchInput) {
              searchButton.addEventListener('click', performSearch);
              searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performSearch();
              });
            }

            if (reviewToggleBtn) reviewToggleBtn.addEventListener('click', toggleReviewMode);
            if (startReviewBtn) startReviewBtn.addEventListener('click', startReviewSession);
            if (clearReviewBtn) clearReviewBtn.addEventListener('click', promptClearReviewData);

            const printBtn = document.querySelector('.wh_print_link button');
            if (printBtn) {
              printBtn.addEventListener('click', (e) => {
                e.preventDefault();
                window.print();
              });
            }
          }

          // Review System Functions
          function initReviewSystem() {
            debug('Initializing review system');
            createCommentDialog();
            updateReviewButtons();
          }

          function createCommentDialog() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'dialog-overlay';
            overlay.id = 'dialogOverlay';
            overlay.addEventListener('click', closeCommentDialog);

            // Create dialog
            const dialog = document.createElement('div');
            dialog.className = 'comment-dialog';
            dialog.id = 'commentDialog';
            dialog.innerHTML = `
              <h3>Add Review Comment</h3>
              <div style="margin-bottom: 15px;">
                <label><input type="radio" name="commentType" value="comment" checked> Comment</label>
                <label style="margin-left: 15px;"><input type="radio" name="commentType" value="suggestion"> Suggestion</label>
              </div>
              <div style="margin: 15px 0;">
                <textarea id="commentText" placeholder="Enter your comment or suggestion..."></textarea>
              </div>
              <div class="dialog-actions">
                <button class="dialog-btn secondary" onclick="closeCommentDialog()">Cancel</button>
                <button class="dialog-btn primary" onclick="saveComment()">Save</button>
              </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);
            debug('Comment dialog created');
          }

          function toggleReviewMode() {
            window.reviewMode = !window.reviewMode;
            
            if (window.reviewMode) {
              document.body.classList.add('review-mode');
              initializeReviewForContent();
              debug('Review mode activated');
            } else {
              document.body.classList.remove('review-mode');
              clearReviewHighlights();
              debug('Review mode deactivated');
            }
            
            updateReviewButtons();
          }

          function updateReviewButtons() {
            if (reviewToggleBtn) {
              reviewToggleBtn.textContent = window.reviewMode ? 'Exit Review' : 'Review Mode';
              reviewToggleBtn.classList.toggle('active', window.reviewMode);
            }
            
            const reviewControls = document.querySelectorAll('.review-btn:not(#reviewToggle)');
            reviewControls.forEach(btn => {
              btn.style.display = window.reviewMode ? 'block' : 'none';
            });
          }

          function initializeReviewForContent() {
            if (!window.reviewMode || !contentEl) return;
            
            // Make text elements selectable
            const textElements = contentEl.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th');
            textElements.forEach(element => {
              element.classList.add('reviewable-text');
              element.addEventListener('mouseup', handleTextSelection);
            });
            
            debug('Review initialization complete for content');
          }

          function handleTextSelection(event) {
            if (!window.reviewMode) return;
            
            const selection = window.getSelection();
            if (selection.toString().trim().length === 0) return;
            
            const selectedText = selection.toString().trim();
            debug('Text selected:', selectedText);
            
            window.currentSelection = {
              type: 'text',
              text: selectedText,
              element: event.target
            };
            
            showCommentDialog();
          }

          function showCommentDialog() {
            const dialog = document.getElementById('commentDialog');
            const overlay = document.getElementById('dialogOverlay');
            
            if (dialog && overlay) {
              dialog.classList.add('show');
              overlay.classList.add('show');
              document.getElementById('commentText').focus();
            }
          }

          function closeCommentDialog() {
            const dialog = document.getElementById('commentDialog');
            const overlay = document.getElementById('dialogOverlay');
            
            if (dialog && overlay) {
              dialog.classList.remove('show');
              overlay.classList.remove('show');
              document.getElementById('commentText').value = '';
              document.querySelector('input[name="commentType"]:checked').checked = false;
              document.querySelector('input[name="commentType"][value="comment"]').checked = true;
            }
            
            window.getSelection().removeAllRanges();
            window.currentSelection = null;
          }

          async function saveComment() {
            if (!window.currentSelection) {
              closeCommentDialog();
              return;
            }
            
            const commentText = document.getElementById('commentText').value.trim();
            const commentType = document.querySelector('input[name="commentType"]:checked').value;
            
            if (!commentText) {
              alert('Please enter a comment.');
              return;
            }
            
            try {
              const commentData = {
                page_id: window.currentPage,
                comment_type: commentType,
                comment_text: commentText,
                selected_text: window.currentSelection.text,
                selection_type: 'text'
              };
              
              debug('Saving comment:', commentData);
              
              const result = await window.supabaseClient.saveComment(commentData);
              debug('Comment saved successfully:', result);
              
              // Add visual highlight
              highlightTextInDocument(window.currentSelection, { 
                id: result[0]?.id, 
                comment_type: commentType 
              });
              
              alert('Comment saved successfully!');
              closeCommentDialog();
              
            } catch (error) {
              debug('Error saving comment:', error);
              alert('Failed to save comment. Please try again.');
            }
          }

          function highlightTextInDocument(selection, comment) {
            if (!selection.element || !selection.text) return;
            
            const span = document.createElement('span');
            span.className = comment.comment_type === 'suggestion' ? 
              'review-suggestion-highlight' : 'review-comment-highlight';
            span.setAttribute('data-comment-id', comment.id);
            span.textContent = selection.text;
            
            // Find and replace the selected text
            const textNodes = getAllTextNodes(selection.element);
            for (const node of textNodes) {
              if (node.textContent.includes(selection.text)) {
                const parent = node.parentNode;
                const index = node.textContent.indexOf(selection.text);
                
                if (index !== -1) {
                  const beforeText = node.textContent.substring(0, index);
                  const afterText = node.textContent.substring(index + selection.text.length);
                  
                  parent.removeChild(node);
                  if (beforeText) parent.appendChild(document.createTextNode(beforeText));
                  parent.appendChild(span);
                  if (afterText) parent.appendChild(document.createTextNode(afterText));
                  break;
                }
              }
            }
          }

          function getAllTextNodes(element) {
            const textNodes = [];
            const walker = document.createTreeWalker(
              element,
              NodeFilter.SHOW_TEXT,
              null,
              false
            );
            
            let node;
            while (node = walker.nextNode()) {
              if (node.textContent.trim()) {
                textNodes.push(node);
              }
            }
            return textNodes;
          }

          function clearReviewHighlights() {
            const highlights = document.querySelectorAll('[data-comment-id]');
            highlights.forEach(highlight => {
              const parent = highlight.parentNode;
              if (parent) {
                parent.insertBefore(document.createTextNode(highlight.textContent), highlight);
                parent.removeChild(highlight);
              }
            });
          }

          function startReviewSession() {
            if (!window.currentPage) {
              alert('Please select a document to review first.');
              return;
            }
            
            if (!window.reviewMode) {
              toggleReviewMode();
            }
            
            alert(`Review session started for "${getPageTitle(window.currentPage)}". Select text to add comments.`);
          }

          function promptClearReviewData() {
            if (confirm('Are you sure you want to clear all review data? This cannot be undone.')) {
              clearReviewData();
            }
          }

          async function clearReviewData() {
            try {
              if (window.supabaseClient) {
                await window.supabaseClient.clearAllComments();
              }
              clearReviewHighlights();
              alert('All review data has been cleared successfully.');
            } catch (error) {
              debug('Error clearing review data:', error);
              alert('Failed to clear review data. Please try again.');
            }
          }

          // Navigation Functions
          function renderNavigation(items, parentEl = navigationEl) {
            const ul = document.createElement('ul');
            ul.setAttribute('role', 'menu');

            items.forEach(item => {
              const li = document.createElement('li');
              li.setAttribute('role', 'presentation');

              if (item.children && item.children.length > 0) {
                li.classList.add('has-children');
                const toggle = document.createElement('span');
                toggle.className = 'toggle-arrow';
                toggle.addEventListener('click', (e) => {
                  e.stopPropagation();
                  li.classList.toggle('expanded');
                });
                li.appendChild(toggle);
              }

              const a = document.createElement('a');
              a.setAttribute('role', 'menuitem');
              a.textContent = item.title;
              a.setAttribute('data-id', item.id);
              a.href = `#${item.id}`;

              a.addEventListener('click', (e) => {
                e.preventDefault();
                if (item.children && item.children.length > 0) {
                  li.classList.toggle('expanded');
                }
                navigateToPage(item.id);
                if (searchResultsEl) searchResultsEl.innerHTML = '';
                if (searchInput) searchInput.value = '';
              });

              li.appendChild(a);
              if (item.children && item.children.length > 0) {
                renderNavigation(item.children, li);
              }
              ul.appendChild(li);
            });

            parentEl.appendChild(ul);
          }

          function navigateToPage(pageId, pushState = true) {
            debug('Navigating to page:', pageId);
            
            if (!pageId) {
              showErrorContent('undefined');
              return;
            }

            updateActiveNavItem(pageId);
            expandNavigationTo(pageId);

            if (pushState) {
              history.pushState({ pageId }, '', `#${pageId}`);
            }

            document.body.classList.add('loading');
            window.currentPage = pageId;

            loadContent(pageId)
              .then(content => {
                const title = getPageTitle(pageId);
                contentTitleEl.textContent = title;
                document.title = title;
                contentEl.innerHTML = content;
                
                if (window.reviewMode) {
                  initializeReviewForContent();
                }
                
                document.body.classList.remove('loading');
                debug('Content loaded successfully for:', pageId);
              })
              .catch(error => {
                showErrorContent(pageId);
              });
          }

          async function loadContent(pageId) {
            const contentPath = `${basePath}/content/${pageId}.html`;
            debug('Fetching from URL:', contentPath);

            try {
              const response = await fetch(contentPath);
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              return await response.text();
            } catch (error) {
              debug('Content fetch error:', error.message);
              throw error;
            }
          }

          function updateActiveNavItem(pageId) {
            const allNavItems = document.querySelectorAll('.sidebar a');
            allNavItems.forEach(item => item.classList.remove('active'));

            const activeItem = document.querySelector(`.sidebar a[data-id="${pageId}"]`);
            if (activeItem) {
              activeItem.classList.add('active');
              let parent = activeItem.parentElement;
              while (parent && !parent.classList.contains('sidebar')) {
                if (parent.classList.contains('has-children')) {
                  parent.classList.add('expanded');
                }
                parent = parent.parentElement;
              }
            }
          }

          function expandNavigationTo(pageId) {
            function findPageInNavigation(items, id, path = []) {
              for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const currentPath = [...path, item];
                if (item.id === id) return currentPath;
                if (item.children && item.children.length > 0) {
                  const result = findPageInNavigation(item.children, id, currentPath);
                  if (result) return result;
                }
              }
              return null;
            }

            const path = findPageInNavigation(navigationConfig, pageId);
            if (!path) return;

            for (let i = 0; i < path.length - 1; i++) {
              const item = path[i];
              const li = document.querySelector(`.sidebar li a[data-id="${item.id}"]`).parentElement;
              li.classList.add('expanded');
            }
          }

          function handlePopState(event) {
            const pageId = event.state?.pageId || getPageIdFromUrl() || navigationConfig[0]?.id;
            debug('Popstate event, loading page:', pageId);
            navigateToPage(pageId, false);
          }

          function getPageIdFromUrl() {
            return window.location.hash.substring(1) || null;
          }

          function getPageTitle(pageId) {
            if (window.contentIdMap && contentIdMap[pageId]) {
              return contentIdMap[pageId].title;
            }

            function findTitleInNav(items, id) {
              for (const item of items) {
                if (item.id === id) return item.title;
                if (item.children && item.children.length > 0) {
                  const title = findTitleInNav(item.children, id);
                  if (title) return title;
                }
              }
              return null;
            }

            const navTitle = findTitleInNav(navigationConfig, pageId);
            if (navTitle) return navTitle;

            return pageId.split(/-|_/).map(word =>
              word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
          }

          function showErrorContent(pageId) {
            console.error('Failed to load content:', pageId);
            contentEl.innerHTML = `
              <div class="error">
                <h2>Content Not Found</h2>
                <p>The requested content "${pageId}" could not be loaded.</p>
                <p>Please select another topic from the navigation menu.</p>
              </div>
            `;
            document.body.classList.remove('loading');
          }

          function showWelcomeScreen() {
            contentTitleEl.textContent = 'Documentation';
            document.title = 'Documentation';
            contentEl.innerHTML = `
              <div class="welcome-screen">
                <h2>Welcome to Automotive Documentation</h2>
                <p>Please select a topic from the navigation menu or use the search bar.</p>
                <p><strong>Review Mode:</strong> Click "Review Mode" to enable collaborative commenting and suggestions.</p>
                <p><strong>Database Integration:</strong> All comments are saved to Supabase and persist across sessions.</p>
              </div>
            `;
            document.body.classList.remove('loading');
          }

          function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchResultsEl.innerHTML = '';

            if (query.length < 2) {
              if (query.length > 0) {
                searchResultsEl.innerHTML = '<li><p>Please enter at least 2 characters to search.</p></li>';
              }
              return;
            }

            debug('Performing search for:', query);
            const results = [];
            
            for (const id in contentIdMap) {
              if (contentIdMap.hasOwnProperty(id) && id !== 'default') {
                const item = contentIdMap[id];
                const title = item.title.toLowerCase();
                const content = item.content ? item.content.toLowerCase() : '';

                let snippet = '';
                let matchCount = 0;

                if (title.includes(query)) {
                  matchCount += 10;
                  snippet = `Found in title: "${highlightMatch(item.title, query)}"`;
                }

                const contentMatches = content.split(query).length - 1;
                if (contentMatches > 0) {
                  matchCount += contentMatches;
                  const matchIndex = content.indexOf(query);
                  const start = Math.max(0, matchIndex - 50);
                  const end = Math.min(content.length, matchIndex + query.length + 50);
                  const context = item.content.substring(start, end);
                  snippet += (snippet ? '<br>' : '') + `...${highlightMatch(context, query)}...`;
                }

                if (matchCount > 0) {
                  results.push({ id: id, title: item.title, snippet: snippet, score: matchCount });
                }
              }
            }

            results.sort((a, b) => b.score - a.score);

            if (results.length === 0) {
              searchResultsEl.innerHTML = '<li><p>No results found for your query.</p></li>';
            } else {
              results.forEach(result => {
                const li = document.createElement('li');
                const link = document.createElement('a');
                link.href = `#${result.id}`;
                link.textContent = result.title;
                link.addEventListener('click', (e) => {
                  e.preventDefault();
                  navigateToPage(result.id);
                  searchResultsEl.innerHTML = '';
                  searchInput.value = '';
                });
                
                li.appendChild(link);
                if (result.snippet) {
                  const p = document.createElement('p');
                  p.innerHTML = result.snippet;
                  li.appendChild(p);
                }
                searchResultsEl.appendChild(li);
              });
            }
          }

          function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
          }

          // Make functions globally available
          window.toggleReviewMode = toggleReviewMode;
          window.startReviewSession = startReviewSession;
          window.promptClearReviewData = promptClearReviewData;
          window.navigateToPage = navigateToPage;
          window.closeCommentDialog = closeCommentDialog;
          window.saveComment = saveComment;

          // Initialize when DOM is ready
          document.addEventListener('DOMContentLoaded', initApp);
          EOF

      # Step 12: Create default content
      - name: Create Default Content
        run: |
          mkdir -p ./site/content

          # Create sample content files
          cat > ./site/content/getting-started-with-cars.html << 'EOF'
          <h1>Getting Started With Cars</h1>
          <p>Welcome to the comprehensive automotive guide. This section covers the basics of car ownership and maintenance.</p>
          <p>Select text in review mode to add comments and suggestions.</p>
          <ul>
            <li>Understanding your vehicle systems</li>
            <li>Basic maintenance schedules and procedures</li>
            <li>Emergency procedures and troubleshooting</li>
            <li>Safety considerations and best practices</li>
          </ul>
          EOF

          cat > ./site/content/car-types.html << 'EOF'
          <h1>Car Types</h1>
          <p>Learn about different types of vehicles and their characteristics.</p>
          <h2>Sedan</h2>
          <p>Four-door passenger car with a separate trunk compartment.</p>
          <h2>SUV</h2>
          <p>Sport Utility Vehicle with higher ground clearance and all-terrain capability.</p>
          <h2>Hatchback</h2>
          <p>Compact car with rear door that opens upward to access cargo area.</p>
          EOF

          cat > ./site/content/basic-maintenance.html << 'EOF'
          <h1>Basic Maintenance</h1>
          <p>Regular maintenance is crucial for vehicle longevity and safety.</p>
          <h2>Oil Changes</h2>
          <p>Change engine oil every 3,000-5,000 miles depending on your vehicle and oil type.</p>
          <h2>Tire Care</h2>
          <p>Check tire pressure monthly and rotate tires every 6,000-8,000 miles.</p>
          <h2>Brake Inspection</h2>
          <p>Have brakes inspected annually and replace brake pads when worn.</p>
          EOF

      # Step 13: Create Enhanced index.html
      - name: Create Enhanced Index HTML
        run: |
          cat > ./site/index.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">

            <script>
              if (location.hostname.includes('github.io')) {
                const pathSegments = location.pathname.split('/');
                if (pathSegments.length > 1) {
                  const basePath = '/' + pathSegments[1];
                  document.write('<base href="' + basePath + '/">');
                }
              }
            </script>

            <title>Automotive Documentation - Complete Review System</title>
            <link rel="stylesheet" href="css/style.css">
          </head>
          <body>
            <div class="sidebar">
              <div class="sidebar-header">
                <h2>Navigation</h2>
                <div class="search-container">
                  <input type="text" id="searchInput" placeholder="Search...">
                  <button id="searchButton">Search</button>
                </div>
                <ul id="searchResults" class="search-results"></ul>
              </div>
              
              <div class="review-controls">
                <h3>Review System</h3>
                <div class="review-mode-toggle">
                  <button id="reviewToggle" class="review-btn">Review Mode</button>
                </div>
                <button id="startReview" class="review-btn secondary">Start Review</button>
                <button id="clearReview" class="review-btn danger">Clear All</button>
              </div>
              
              <div class="sidebar-nav">
                <div id="navigation"></div>
              </div>
            </div>

            <div class="main-content">
              <h1 id="content-title">Loading...</h1>
              <div id="loading">Loading content...</div>
              <div id="content">
                <div class="initial-loading">
                  <p>Initializing enhanced documentation viewer with complete review system...</p>
                </div>
              </div>
            </div>

            <div class="wh_print_link" style="position: fixed; top: 10px; right: 10px; z-index: 999;">
              <button title="Print page">ðŸ–¨ï¸ Print</button>
            </div>

            <script src="js/supabase-config.js"></script>
            <script src="js/navigation-config.js"></script>
            <script src="js/content-id-map.js"></script>
            <script src="js/app.js"></script>
          </body>
          </html>
          EOF

      # Step 14: Create 404.html
      - name: Create 404 Page
        run: |
          cat > ./site/404.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Redirecting...</title>
            <script>
              sessionStorage.redirect = location.href;
              function getBasePath() {
                if (location.hostname.includes('github.io')) {
                  const pathSegments = location.pathname.split('/');
                  if (pathSegments.length > 1) return '/' + pathSegments[1];
                }
                return '';
              }
              const basePath = getBasePath();
              window.location.href = basePath + '/';
            </script>
          </head>
          <body>
            <div style="text-align: center; font-family: Arial, sans-serif; margin-top: 100px;">
              <h1>Redirecting...</h1>
              <p>If you are not redirected automatically, <a href="/">click here</a>.</p>
            </div>
          </body>
          </html>
          EOF

      # Step 15: Deploy to GitHub Pages
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site
          force_orphan: true

    env:
      SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}