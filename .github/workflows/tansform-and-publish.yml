name: DITA to SPA with Staticman Comments System

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Create Staticman Configuration
        run: |
          cat > staticman.yml << 'EOF'
          comments:
            allowedFields: ["name", "email", "url", "message", "pageId", "commentType", "selectedText", "selectionType", "position"]
            branch: "main"
            commitMessage: "New comment by {fields.name} on {options.pageId}"
            filename: "comment-{@timestamp}"
            format: "json"
            transforms:
              email: md5
            moderation: true
            pullRequestBody: "New comment for approval"
            path: "_data/comments/{options.pageId}"
            requiredFields: ["name", "message", "pageId"]
            generatedFields:
              date:
                type: "date"
                options:
                  format: "iso8601"
              id:
                type: "date"
                options:
                  format: "timestamp"
          EOF

      - name: Set up DITA-OT
        run: |
          sudo apt-get update
          sudo apt-get install -y libxml2-utils xsltproc
          wget https://github.com/dita-ot/dita-ot/releases/download/4.0.2/dita-ot-4.0.2.zip
          unzip dita-ot-4.0.2.zip
          chmod +x dita-ot-4.0.2/bin/dita

      - name: Parse DITAMAP Structure
        run: |
          cat > extract-nav.xsl << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:output method="text"/>
            <xsl:template match="/">
              [<xsl:apply-templates select="//topicref[not(ancestor::topicref)]"/>]
            </xsl:template>
            <xsl:template match="topicref">
              <xsl:variable name="id" select="translate(substring-before(@href, '.'), '_', '-')"/>
              <xsl:variable name="title" select="@navtitle"/>
              {
                "id": "<xsl:value-of select="$id"/>",
                "title": "<xsl:value-of select="$title"/>",
                "href": "<xsl:value-of select="@href"/>"
                <xsl:if test="topicref">,
                "children": [<xsl:apply-templates select="topicref"/>]</xsl:if>
              }<xsl:if test="following-sibling::topicref">,</xsl:if>
            </xsl:template>
          </xsl:stylesheet>
          EOF
          
          xsltproc extract-nav.xsl dita-source/automotive.ditamap > navigation-structure.json || echo '[]' > navigation-structure.json

      - name: Transform DITA to HTML
        run: |
          ./dita-ot-4.0.2/bin/dita --input=dita-source/automotive.ditamap --format=html5 --output=./site || echo "DITA transformation completed"
          mkdir -p ./site/content ./site/images ./site/js ./site/css ./site/_data/comments
          find ./dita-source -type f \( -name "*.jpg" -o -name "*.png" -o -name "*.gif" -o -name "*.svg" \) -exec cp {} ./site/images/ \; 2>/dev/null || true

      - name: Process HTML Content
        run: |
          find ./site -name "*.html" ! -name "index.html" ! -name "404.html" | while read file; do
            filename=$(basename "$file" .html)
            sed -n '/<body/,/<\/body>/p' "$file" | sed '/<body/d; /<\/body>/d' > "./site/content/$filename.html" || echo "Processed $filename"
          done

      - name: Create JavaScript Files
        run: |
          # Get repository info
          REPO_OWNER="${GITHUB_REPOSITORY%/*}"
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          
          # Navigation config
          echo "const navigationConfig = " > ./site/js/navigation-config.js
          cat navigation-structure.json >> ./site/js/navigation-config.js
          echo ";" >> ./site/js/navigation-config.js
          
          # Staticman config template
          cat > ./site/js/staticman-config.js << 'EOF'
          window.staticmanConfig = {
            endpoint: 'https://api.staticman.net/v3/entry/github/PLACEHOLDER_OWNER/PLACEHOLDER_NAME/PLACEHOLDER_BRANCH/comments',
            repository: 'PLACEHOLDER_OWNER/PLACEHOLDER_NAME',
            branch: 'PLACEHOLDER_BRANCH',
            enabled: true,
            moderation: true,
            setup: {
              inviteUrl: 'https://api.staticman.net/v3/connect/github/PLACEHOLDER_OWNER/PLACEHOLDER_NAME',
              docsUrl: 'https://staticman.net/docs/',
              repositoryUrl: 'https://github.com/PLACEHOLDER_OWNER/PLACEHOLDER_NAME'
            }
          };
          EOF
          
          # Replace placeholders
          sed -i "s/PLACEHOLDER_OWNER/$REPO_OWNER/g" ./site/js/staticman-config.js
          sed -i "s/PLACEHOLDER_NAME/$REPO_NAME/g" ./site/js/staticman-config.js
          sed -i "s/PLACEHOLDER_BRANCH/$BRANCH_NAME/g" ./site/js/staticman-config.js

      - name: Create Comments System
        run: |
          cat > ./site/js/comments-loader.js << 'EOF'
          class CommentsLoader {
            constructor() {
              this.comments = {};
              this.loadExistingComments();
            }
            
            async loadExistingComments() {
              try {
                if (window.preloadedComments) {
                  this.comments = window.preloadedComments;
                }
              } catch (error) {
                console.log('No existing comments found');
              }
            }
            
            getCommentsForPage(pageId) {
              return this.comments[pageId] || [];
            }
          }
          
          window.commentsLoader = new CommentsLoader();
          window.getCommentsForPage = (pageId) => window.commentsLoader.getCommentsForPage(pageId);
          EOF
          
          echo "window.preloadedComments = {};" > ./site/js/preloaded-comments.js

      - name: Create Staticman Integration
        run: |
          cat > ./site/js/staticman-integration.js << 'EOF'
          class StaticmanIntegration {
            constructor() {
              this.config = window.staticmanConfig;
              this.status = 'disconnected';
              this.testConnection();
            }
            
            async testConnection() {
              if (!this.config?.endpoint) {
                this.setStatus('error', 'Staticman not configured');
                return;
              }
              
              try {
                this.setStatus('connecting', 'Testing connection...');
                const response = await fetch(this.config.endpoint.replace('/entry/', '/'), {
                  method: 'GET',
                  mode: 'cors'
                }).catch(() => ({ ok: false }));
                
                if (response.ok || response.status === 404) {
                  this.setStatus('connected', 'Staticman connected');
                } else {
                  throw new Error('Service unavailable');
                }
              } catch (error) {
                this.setStatus('error', 'Connection failed - click for help');
              }
            }
            
            async submitComment(commentData) {
              try {
                this.setStatus('submitting', 'Submitting comment...');
                
                const response = await fetch(this.config.endpoint, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    fields: commentData,
                    options: { pageId: commentData.pageId }
                  })
                });
                
                if (!response.ok) {
                  throw new Error('HTTP ' + response.status);
                }
                
                this.setStatus('submitted', 'Comment submitted for review');
                return {
                  success: true,
                  moderated: true,
                  message: 'Comment submitted for review'
                };
              } catch (error) {
                this.setStatus('error', 'Submission failed: ' + error.message);
                throw error;
              }
            }
            
            setStatus(status, message) {
              this.status = status;
              this.updateStatusUI(status, message);
            }
            
            updateStatusUI(status, message) {
              let statusEl = document.getElementById('staticman-status');
              if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'staticman-status';
                statusEl.className = 'staticman-status';
                const sidebar = document.querySelector('.sidebar');
                if (sidebar) sidebar.insertBefore(statusEl, sidebar.firstChild);
              }
              
              statusEl.className = 'staticman-status status-' + status;
              statusEl.textContent = message;
              
              if (status === 'error') {
                statusEl.style.cursor = 'pointer';
                statusEl.onclick = () => this.showSetupHelp();
              }
            }
            
            showSetupHelp() {
              alert('Staticman Setup:\n\n1. Add staticmanapp as collaborator\n2. Visit: ' + this.config.setup.inviteUrl + '\n3. Test the integration');
            }
          }
          
          window.staticmanIntegration = new StaticmanIntegration();
          EOF

      - name: Create Content Map
        run: |
          echo "const contentMap = {" > ./site/js/content-map.js
          find ./site/content -name "*.html" | while read file; do
            id=$(basename "$file" .html)
            title=$(echo "$id" | tr '-' ' ' | sed 's/\b\w/\U&/g')
            echo "  \"$id\": { \"title\": \"$title\", \"content\": \"Sample content\" }," >> ./site/js/content-map.js
          done
          echo "};" >> ./site/js/content-map.js

      - name: Create Main Application
        run: |
          cat > ./site/js/app.js << 'EOF'
          class DocumentationSPA {
            constructor() {
              this.currentPage = null;
              this.reviewMode = false;
              this.currentSelection = null;
              this.init();
            }
            
            init() {
              this.setupEventListeners();
              this.renderNavigation();
              this.setupCommentsSystem();
              this.loadInitialPage();
            }
            
            setupEventListeners() {
              window.addEventListener('popstate', (e) => {
                const pageId = e.state?.pageId || this.getPageFromHash();
                if (pageId) this.navigateToPage(pageId, false);
              });
              
              const searchBtn = document.getElementById('search-btn');
              const searchInput = document.getElementById('search-input');
              if (searchBtn && searchInput) {
                searchBtn.addEventListener('click', () => this.performSearch());
                searchInput.addEventListener('keypress', (e) => {
                  if (e.key === 'Enter') this.performSearch();
                });
              }
              
              const reviewToggle = document.getElementById('review-toggle');
              if (reviewToggle) {
                reviewToggle.addEventListener('click', () => this.toggleReviewMode());
              }
            }
            
            renderNavigation() {
              const navContainer = document.getElementById('navigation');
              if (!navContainer || !window.navigationConfig) return;
              this.createNavItems(window.navigationConfig, navContainer);
            }
            
            createNavItems(items, container) {
              const ul = document.createElement('ul');
              items.forEach(item => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.textContent = item.title;
                a.href = '#' + item.id;
                a.addEventListener('click', (e) => {
                  e.preventDefault();
                  this.navigateToPage(item.id);
                });
                li.appendChild(a);
                if (item.children) {
                  this.createNavItems(item.children, li);
                }
                ul.appendChild(li);
              });
              container.appendChild(ul);
            }
            
            async navigateToPage(pageId, pushState = true) {
              if (!pageId) return;
              this.currentPage = pageId;
              this.updateActiveNavItem(pageId);
              
              if (pushState) {
                history.pushState({ pageId }, '', '#' + pageId);
              }
              
              try {
                const content = await this.loadContent(pageId);
                this.displayContent(content, pageId);
                this.loadCommentsForPage(pageId);
              } catch (error) {
                this.displayError(pageId);
              }
            }
            
            async loadContent(pageId) {
              const response = await fetch('content/' + pageId + '.html');
              if (!response.ok) throw new Error('Content not found');
              return await response.text();
            }
            
            displayContent(content, pageId) {
              const contentContainer = document.getElementById('main-content');
              const titleContainer = document.getElementById('page-title');
              
              if (contentContainer) {
                contentContainer.innerHTML = content;
                this.setupContentInteractivity();
              }
              
              if (titleContainer && window.contentMap && window.contentMap[pageId]) {
                titleContainer.textContent = window.contentMap[pageId].title;
                document.title = window.contentMap[pageId].title;
              }
            }
            
            displayError(pageId) {
              const contentContainer = document.getElementById('main-content');
              if (contentContainer) {
                contentContainer.innerHTML = '<div class="error-message"><h2>Content Not Found</h2><p>The requested page could not be loaded.</p></div>';
              }
            }
            
            setupContentInteractivity() {
              if (this.reviewMode) {
                this.makeContentReviewable();
              }
            }
            
            makeContentReviewable() {
              const textElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td');
              textElements.forEach(el => {
                el.addEventListener('mouseup', (e) => this.handleTextSelection(e));
                el.style.cursor = 'text';
              });
              
              const images = document.querySelectorAll('img');
              images.forEach(img => {
                img.addEventListener('click', (e) => this.handleImageClick(e));
                img.style.cursor = 'crosshair';
              });
            }
            
            handleTextSelection(event) {
              const selection = window.getSelection();
              const selectedText = selection.toString().trim();
              
              if (selectedText.length > 0) {
                this.currentSelection = {
                  type: 'text',
                  text: selectedText,
                  element: event.target,
                  range: selection.getRangeAt(0).cloneRange()
                };
                setTimeout(() => this.showCommentDialog(), 100);
              }
            }
            
            handleImageClick(event) {
              const img = event.target;
              const rect = img.getBoundingClientRect();
              const x = ((event.clientX - rect.left) / rect.width) * 100;
              const y = ((event.clientY - rect.top) / rect.height) * 100;
              
              this.currentSelection = {
                type: 'image',
                element: img,
                position: { x, y },
                imageSrc: img.src,
                imageAlt: img.alt || 'Image'
              };
              this.showCommentDialog();
            }
            
            showCommentDialog() {
              const dialog = document.getElementById('comment-dialog');
              const overlay = document.getElementById('dialog-overlay');
              
              if (dialog && overlay) {
                dialog.classList.add('show');
                overlay.classList.add('show');
                const nameInput = document.getElementById('comment-name');
                if (nameInput) nameInput.focus();
              }
            }
            
            hideCommentDialog() {
              const dialog = document.getElementById('comment-dialog');
              const overlay = document.getElementById('dialog-overlay');
              
              if (dialog && overlay) {
                dialog.classList.remove('show');
                overlay.classList.remove('show');
              }
              this.currentSelection = null;
              window.getSelection().removeAllRanges();
            }
            
            async submitComment() {
              if (!this.currentSelection || !window.staticmanIntegration) {
                this.hideCommentDialog();
                return;
              }
              
              const name = document.getElementById('comment-name')?.value?.trim();
              const email = document.getElementById('comment-email')?.value?.trim();
              const message = document.getElementById('comment-message')?.value?.trim();
              const commentType = document.querySelector('input[name="comment-type"]:checked')?.value || 'comment';
              
              if (!name || !message) {
                alert('Please fill in your name and comment message.');
                return;
              }
              
              const commentData = {
                name, email, message,
                pageId: this.currentPage,
                commentType,
                selectedText: this.currentSelection.text || this.currentSelection.imageAlt || 'Selected content',
                selectionType: this.currentSelection.type,
                timestamp: new Date().toISOString()
              };
              
              if (this.currentSelection.type === 'image') {
                commentData.position = JSON.stringify(this.currentSelection.position);
                commentData.imageSrc = this.currentSelection.imageSrc;
                commentData.imageAlt = this.currentSelection.imageAlt;
              }
              
              try {
                const result = await window.staticmanIntegration.submitComment(commentData);
                if (result.success) {
                  this.hideCommentDialog();
                  alert(result.moderated ? 'Comment submitted for review!' : 'Comment submitted!');
                }
              } catch (error) {
                alert('Failed to submit comment: ' + error.message);
              }
            }
            
            toggleReviewMode() {
              this.reviewMode = !this.reviewMode;
              const toggleBtn = document.getElementById('review-toggle');
              
              if (toggleBtn) {
                toggleBtn.textContent = this.reviewMode ? 'Exit Review Mode' : 'Enable Review Mode';
                toggleBtn.classList.toggle('active', this.reviewMode);
              }
              
              document.body.classList.toggle('review-mode', this.reviewMode);
              if (this.reviewMode) this.setupContentInteractivity();
            }
            
            loadCommentsForPage(pageId) {
              if (window.commentsLoader) {
                const comments = window.commentsLoader.getCommentsForPage(pageId);
                this.displayComments(comments);
              }
            }
            
            displayComments(comments) {
              const commentsContainer = document.getElementById('comments-container');
              if (!commentsContainer || !comments.length) return;
              
              commentsContainer.innerHTML = comments.map(comment => 
                '<div class="comment">' +
                '<div class="comment-header">' +
                '<strong>' + comment.name + '</strong>' +
                '<span class="comment-date">' + new Date(comment.date).toLocaleDateString() + '</span>' +
                '<span class="comment-type ' + comment.commentType + '">' + comment.commentType + '</span>' +
                '</div>' +
                (comment.selectedText ? '<div class="comment-context">"' + comment.selectedText + '"</div>' : '') +
                '<div class="comment-message">' + comment.message + '</div>' +
                '</div>'
              ).join('');
            }
            
            performSearch() {
              const searchInput = document.getElementById('search-input');
              const resultsContainer = document.getElementById('search-results');
              
              if (!searchInput || !resultsContainer || !window.contentMap) return;
              
              const query = searchInput.value.toLowerCase().trim();
              resultsContainer.innerHTML = '';
              
              if (query.length < 2) return;
              
              const results = Object.entries(window.contentMap)
                .filter(([id, data]) => 
                  data.title.toLowerCase().includes(query) || 
                  data.content.toLowerCase().includes(query)
                )
                .slice(0, 10);
              
              results.forEach(([id, data]) => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.textContent = data.title;
                a.href = '#' + id;
                a.addEventListener('click', (e) => {
                  e.preventDefault();
                  this.navigateToPage(id);
                  resultsContainer.innerHTML = '';
                  searchInput.value = '';
                });
                li.appendChild(a);
                resultsContainer.appendChild(li);
              });
            }
            
            updateActiveNavItem(pageId) {
              document.querySelectorAll('.sidebar a').forEach(a => a.classList.remove('active'));
              const activeLink = document.querySelector('.sidebar a[href="#' + pageId + '"]');
              if (activeLink) activeLink.classList.add('active');
            }
            
            getPageFromHash() {
              return window.location.hash.slice(1) || null;
            }
            
            loadInitialPage() {
              const pageId = this.getPageFromHash();
              if (pageId) {
                this.navigateToPage(pageId, false);
              } else if (window.navigationConfig && window.navigationConfig.length > 0) {
                this.navigateToPage(window.navigationConfig[0].id, false);
              }
            }
            
            setupCommentsSystem() {
              this.createCommentDialog();
              document.addEventListener('commentsUpdated', (e) => {
                if (e.detail.pageId === this.currentPage) {
                  this.displayComments(e.detail.comments);
                }
              });
            }
            
            createCommentDialog() {
              const dialogHTML = 
                '<div id="dialog-overlay" class="dialog-overlay"></div>' +
                '<div id="comment-dialog" class="comment-dialog">' +
                '<h3>Add Comment</h3>' +
                '<div class="form-group">' +
                '<input type="text" id="comment-name" placeholder="Your name (required)" required>' +
                '<input type="email" id="comment-email" placeholder="Your email (optional)">' +
                '</div>' +
                '<div class="form-group">' +
                '<label><input type="radio" name="comment-type" value="comment" checked> Comment</label>' +
                '<label><input type="radio" name="comment-type" value="suggestion"> Suggestion</label>' +
                '</div>' +
                '<div class="form-group">' +
                '<textarea id="comment-message" placeholder="Your comment or suggestion..." required></textarea>' +
                '</div>' +
                '<div class="dialog-actions">' +
                '<button type="button" onclick="app.hideCommentDialog()">Cancel</button>' +
                '<button type="button" onclick="app.submitComment()" class="primary">Submit Comment</button>' +
                '</div>' +
                '</div>';
              
              document.body.insertAdjacentHTML('beforeend', dialogHTML);
              
              document.getElementById('dialog-overlay').addEventListener('click', () => {
                this.hideCommentDialog();
              });
            }
          }
          
          let app;
          document.addEventListener('DOMContentLoaded', () => {
            app = new DocumentationSPA();
            window.app = app;
          });
          EOF

      - name: Create CSS
        run: |
          cat > ./site/css/styles.css << 'EOF'
          * { margin: 0; padding: 0; box-sizing: border-box; }
          
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8fafc;
            display: flex;
            min-height: 100vh;
          }
          
          .sidebar {
            width: 300px;
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
            height: 100vh;
            overflow-y: auto;
            padding: 1rem;
            box-shadow: 2px 0 4px rgba(0,0,0,0.05);
          }
          
          .sidebar h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
            border-bottom: 2px solid #4299e1;
            padding-bottom: 0.5rem;
          }
          
          .staticman-status {
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            text-align: center;
          }
          
          .staticman-status.status-connected {
            background-color: #c6f6d5;
            color: #22543d;
          }
          
          .staticman-status.status-error {
            background-color: #fed7d7;
            color: #742a2a;
            cursor: pointer;
          }
          
          .staticman-status.status-connecting {
            background-color: #bee3f8;
            color: #2a4365;
          }
          
          .search-container {
            margin-bottom: 1rem;
            display: flex;
            gap: 0.5rem;
          }
          
          .search-container input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.375rem;
          }
          
          .search-container button {
            padding: 0.5rem 1rem;
            background-color: #4299e1;
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
          }
          
          .sidebar ul {
            list-style: none;
            margin: 0;
            padding: 0;
          }
          
          .sidebar a {
            display: block;
            padding: 0.5rem 0.75rem;
            color: #4a5568;
            text-decoration: none;
            border-radius: 0.375rem;
            transition: all 0.2s;
          }
          
          .sidebar a:hover {
            background-color: #edf2f7;
          }
          
          .sidebar a.active {
            background-color: #4299e1;
            color: white;
          }
          
          .review-controls {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e2e8f0;
          }
          
          #review-toggle {
            width: 100%;
            padding: 0.75rem;
            background-color: #805ad5;
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
          }
          
          #review-toggle.active {
            background-color: #f56565;
          }
          
          .main-content {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            height: 100vh;
          }
          
          #page-title {
            color: #2d3748;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            border-bottom: 3px solid #4299e1;
            padding-bottom: 0.5rem;
          }
          
          .review-mode p:hover,
          .review-mode h1:hover, .review-mode h2:hover, .review-mode h3:hover, .review-mode h4:hover,
          .review-mode li:hover, .review-mode td:hover {
            background-color: rgba(66, 153, 225, 0.1);
            border-radius: 0.25rem;
          }
          
          .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
          }
          
          .dialog-overlay.show { display: block; }
          
          .comment-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 20px 25px rgba(0,0,0,0.25);
            width: 90%;
            max-width: 500px;
            display: none;
            z-index: 1001;
          }
          
          .comment-dialog.show { display: block; }
          
          .form-group { margin-bottom: 1rem; }
          
          .form-group input,
          .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.375rem;
            font-family: inherit;
          }
          
          .form-group textarea {
            height: 100px;
            resize: vertical;
          }
          
          .dialog-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
          }
          
          .dialog-actions button {
            padding: 0.75rem 1.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.375rem;
            cursor: pointer;
          }
          
          .dialog-actions button.primary {
            background-color: #4299e1;
            color: white;
            border-color: #4299e1;
          }
          
          .comment {
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
          }
          
          .comment-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
            font-size: 0.875rem;
          }
          
          .comment-type {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
          }
          
          .comment-type.comment {
            background-color: #bee3f8;
            color: #2a4365;
          }
          
          .comment-type.suggestion {
            background-color: #faf089;
            color: #744210;
          }
          
          .error-message {
            background-color: #fed7d7;
            color: #742a2a;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
          }
          
          @media (max-width: 768px) {
            body { flex-direction: column; }
            .sidebar { width: 100%; height: auto; max-height: 40vh; }
            .main-content { height: auto; padding: 1rem; }
          }
          EOF

      - name: Create HTML Structure
        run: |
          cat > ./site/index.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Documentation with Staticman Comments</title>
            <link rel="stylesheet" href="css/styles.css">
          </head>
          <body>
            <aside class="sidebar">
              <h2>Documentation</h2>
              <div class="search-container">
                <input type="text" id="search-input" placeholder="Search...">
                <button id="search-btn">Search</button>
              </div>
              <ul id="search-results"></ul>
              <nav id="navigation"></nav>
              <div class="review-controls">
                <h3>Collaborative Review</h3>
                <button id="review-toggle">Enable Review Mode</button>
              </div>
            </aside>
            
            <main class="main-content">
              <h1 id="page-title">Loading...</h1>
              <div id="main-content">
                <div style="text-align: center; padding: 3rem;">
                  <h2>Welcome to Interactive Documentation</h2>
                  <p>Select a topic from the sidebar to begin.</p>
                  <p><strong>Collaborative Features:</strong> Enable review mode to add comments via Staticman.</p>
                </div>
              </div>
              <section id="comments-container"></section>
            </main>
            
            <script src="js/staticman-config.js"></script>
            <script src="js/preloaded-comments.js"></script>
            <script src="js/comments-loader.js"></script>
            <script src="js/staticman-integration.js"></script>
            <script src="js/navigation-config.js"></script>
            <script src="js/content-map.js"></script>
            <script src="js/app.js"></script>
          </body>
          </html>
          EOF
          
          cat > ./site/404.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <title>Redirecting...</title>
            <script>
              const segments = location.pathname.split('/');
              const basePath = segments.length > 1 ? '/' + segments[1] : '';
              location.replace(basePath + '/' + location.hash);
            </script>
          </head>
          <body><p>Redirecting...</p></body>
          </html>
          EOF

      - name: Copy Configuration and Create Setup Docs
        run: |
          cp staticman.yml ./site/
          touch ./site/.nojekyll
          
          REPO_OWNER="${GITHUB_REPOSITORY%/*}"
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          
          cat > ./site/STATICMAN_SETUP.md << 'EOF'
          # Staticman Setup Instructions
          
          ## Quick Setup
          1. Add `staticmanapp` as repository collaborator
          2. Visit setup URL to connect Staticman
          3. Enable review mode and test comments
          
          ## Configuration
          Repository: REPO_PLACEHOLDER
          Branch: BRANCH_PLACEHOLDER
          Endpoint: https://api.staticman.net/v3/entry/github/REPO_PLACEHOLDER/BRANCH_PLACEHOLDER/comments
          
          ## Setup URL
          https://api.staticman.net/v3/connect/github/REPO_PLACEHOLDER
          
          Comments are stored in `_data/comments/` and create pull requests for moderation.
          EOF
          
          sed -i "s/REPO_PLACEHOLDER/$REPO_OWNER\/$REPO_NAME/g" ./site/STATICMAN_SETUP.md
          sed -i "s/BRANCH_PLACEHOLDER/$BRANCH_NAME/g" ./site/STATICMAN_SETUP.md

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site
          force_orphan: true