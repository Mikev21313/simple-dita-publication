name: DITA to SPA with Fixed Review Window System

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Set up Java (required for DITA-OT)
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Step 3: Install DITA-OT and required tools
      - name: Set up DITA-OT and XML tools
        run: |
          sudo apt-get update
          sudo apt-get install -y libxml2-utils xsltproc postgresql-client curl jq

          # Install DITA-OT
          wget https://github.com/dita-ot/dita-ot/releases/download/4.0.2/dita-ot-4.0.2.zip
          unzip dita-ot-4.0.2.zip
          chmod +x dita-ot-4.0.2/bin/dita

      # Step 4: Verify Enhanced Database Connection
      - name: Verify Enhanced Database Connection
        run: |
          echo "🔄 Verifying enhanced database connection and schema..."
          
          # Test connection with multiple attempts
          for i in {1..3}; do
            echo "Connection attempt $i..."
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -X GET \
              -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
              -H "apikey: ${{ secrets.SUPABASE_SERVICE_KEY }}" \
              "https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/")
            
            if [ "$RESPONSE" -eq 200 ]; then
              echo "✅ Supabase connection successful on attempt $i"
              break
            else
              echo "❌ Attempt $i failed with status: $RESPONSE"
              if [ $i -eq 3 ]; then
                exit 1
              fi
              sleep 2
            fi
          done

          # Verify table existence
          echo "🔍 Verifying database tables..."
          TABLES_RESPONSE=$(curl -s -X GET \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "apikey: ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            "https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/comments?limit=1")
          
          if [[ "$TABLES_RESPONSE" == *"relation"*"does not exist"* ]]; then
            echo "❌ Database tables missing - please run the schema setup SQL"
            exit 1
          else
            echo "✅ Database tables verified and accessible"
          fi

          # Test write permissions
          echo "🔧 Testing write permissions..."
          TEST_WRITE=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "apikey: ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{"page_id":"test","comment_text":"connection test","selected_text":"test"}' \
            "https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/comments")
          
          if [ "$TEST_WRITE" -eq 201 ]; then
            echo "✅ Write permissions verified"
            # Clean up test data
            curl -s -X DELETE \
              -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
              -H "apikey: ${{ secrets.SUPABASE_SERVICE_KEY }}" \
              "https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/comments?page_id=eq.test" > /dev/null
          else
            echo "⚠️ Write test returned: $TEST_WRITE (may be RLS policy - will work with anon key)"
          fi

          echo "✅ Database connection and permissions verified - Review system ready"

      # Step 5: Parse DITAMAP to generate navigation structure
      - name: Parse DITAMAP Structure
        run: |
          echo "📖 Parsing DITAMAP structure from dita-source/automotive.ditamap"

          # Create XSLT file for navigation extraction
          cat > extract-nav.xsl << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:output method="text"/>
            <xsl:template match="/">
              [<xsl:apply-templates select="//topicref[not(ancestor::topicref)]"/>]
            </xsl:template>
            <xsl:template match="topicref">
              <xsl:variable name="href" select="@href"/>
              <xsl:variable name="filename">
                <xsl:choose>
                  <xsl:when test="contains($href, '/')">
                    <xsl:value-of select="substring-after(substring-before($href, '.'), '/')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="substring-before($href, '.')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="id">
                <xsl:choose>
                  <xsl:when test="@id"><xsl:value-of select="@id"/></xsl:when>
                  <xsl:otherwise><xsl:value-of select="translate($filename, '_', '-')"/></xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="title">
                <xsl:choose>
                  <xsl:when test="@navtitle"><xsl:value-of select="@navtitle"/></xsl:when>
                  <xsl:when test="topicmeta/navtitle"><xsl:value-of select="topicmeta/navtitle"/></xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="translate(translate($id, '-', ' '), '_', ' ')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              {
                "id": "<xsl:value-of select="$id"/>",
                "title": "<xsl:value-of select="$title"/>",
                "filename": "<xsl:value-of select="$filename"/>",
                "href": "<xsl:value-of select="$href"/>"
                <xsl:if test="topicref">
                  ,"children": [<xsl:apply-templates select="topicref"/>]
                </xsl:if>
              }<xsl:if test="following-sibling::topicref">,</xsl:if>
            </xsl:template>
          </xsl:stylesheet>
          EOF

          # Apply XSLT transformation
          xsltproc extract-nav.xsl dita-source/automotive.ditamap > navigation-structure.json || echo "[]" > navigation-structure.json
          sed -i 's/\\n//g; s/\\t//g; s/  / /g' navigation-structure.json

          echo "✅ DITAMAP parsing complete"
          cat navigation-structure.json

      # Step 6: Transform DITA to HTML
      - name: Transform DITA to HTML and Prepare Images
        run: |
          ./dita-ot-4.0.2/bin/dita --input=dita-source/automotive.ditamap --format=html5 --output=./site || echo "DITA transformation completed"
          
          mkdir -p ./site/content ./site/images ./site/js ./site/css ./site/archives ./site/review

          # Copy images
          find ./dita-source -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.svg" \) -exec cp -v {} ./site/images/ \; || echo "No images found"

          # Create placeholder if no images
          if [ ! "$(ls -A ./site/images 2>/dev/null)" ]; then
            echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" | base64 -d > ./site/images/placeholder.png
          fi

      # Step 7: Process HTML content for SPA
      - name: Process HTML Content
        run: |
          # Process HTML files to create SPA content
          find ./site -type f -name "*.html" | grep -v "index.html" | grep -v "404.html" | grep -v "review.html" | while read file; do
            if [[ "$file" == "./site/index.html" ]]; then continue; fi

            filename=$(basename "$file")
            id="${filename%.html}"
            hyphenated_id="${id//_/-}"

            # Extract content
            content=$(sed -n '/<body/,/<\/body>/p' "$file" | sed '/<body/d;/<\/body>/d' | sed '/<header/,/<\/header>/d' | sed '/<nav/,/<\/nav>/d' | sed '/<footer/,/<\/footer>/d')
            
            # Fix image paths
            content=$(echo "$content" | sed -E 's/<img([^>]*)src="[^"]*\/([^\/"]*)\.([a-zA-Z0-9]+)"/<img\1src="images\/\2.\3"/gi')
            content=$(echo "$content" | sed -E 's/<img([^>]*)src="([^\/:"]*)\.(jpg|jpeg|png|gif|svg)"/<img\1src="images\/\2.\3"/gi')

            # Get title
            title=$(grep -o "<title>.*</title>" "$file" | sed 's/<title>\(.*\)<\/title>/\1/' | head -1)
            if [ -z "$title" ]; then
              title=$(echo "$id" | tr '_-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')
            fi

            # Create content files
            echo "$content" > "./site/content/$id.html"
            if [[ "$id" != "$hyphenated_id" ]]; then
              echo "$content" > "./site/content/$hyphenated_id.html"
            fi
          done

          # Create content ID mapping
          echo "// Auto-generated content ID mapping" > ./site/js/content-id-map.js
          echo "const contentIdMap = {" >> ./site/js/content-id-map.js

          find ./site -type f -name "*.html" | grep -v "index.html" | grep -v "404.html" | grep -v "review.html" | while read file; do
            filename=$(basename "$file" .html)
            id="${filename//_/-}"
            original_filename="$filename"
            title=$(grep -o "<title>.*</title>" "$file" | sed 's/<title>\(.*\)<\/title>/\1/' | head -1)
            raw_content=$(cat "$file" | tr '\n' ' ' | sed 's/<[^>]*>//g' | sed 's/&nbsp;/ /g' | sed 's/  */ /g' | tr -d '\n\r')

            if grep -q "\"$id\":" ./site/js/content-id-map.js; then continue; fi

            if [ -z "$title" ]; then
              title=$(echo "$id" | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')
            fi

            title=$(echo "$title" | sed 's/"/\\"/g')
            raw_content=$(echo "$raw_content" | sed 's/"/\\"/g')

            echo "  \"$id\": { \"title\": \"$title\", \"filename\": \"$original_filename\", \"content\": \"$raw_content\" }," >> ./site/js/content-id-map.js
          done

          echo "  \"default\": { \"title\": \"Automotive Documentation\", \"filename\": \"\", \"content\": \"\" }" >> ./site/js/content-id-map.js
          echo "};" >> ./site/js/content-id-map.js

      # Step 8: Generate Navigation Configuration
      - name: Generate Navigation Configuration
        run: |
          cat > ./site/js/navigation-config.js << 'EOF'
          // Auto-generated navigation structure from DITAMAP
          const navigationConfig =
          EOF
          cat ./navigation-structure.json >> ./site/js/navigation-config.js
          echo ";" >> ./site/js/navigation-config.js

      # Step 9: Create Enhanced Supabase Configuration with Connection Testing
      - name: Create Enhanced Supabase Configuration
        run: |
          cat > ./site/js/supabase-config.js << 'EOF'
          // Enhanced Supabase configuration with robust connection handling
          const SUPABASE_URL = 'https://oiluavgeyngmkqozzmnz.supabase.co';
          const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9pbHVhdmdleW5nbWtxb3p6bW56Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0NjIxOTgsImV4cCI6MjA2NDAzODE5OH0.zsfYoYDgArOBjP7SziUMgRQpIHhwTb-qgtw7t54MsXQ';

          class SupabaseClient {
            constructor() {
              this.baseUrl = SUPABASE_URL;
              this.headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'apikey': SUPABASE_ANON_KEY
              };
              this.connected = false;
              this.debugMode = true;
              this.retryAttempts = 3;
            }

            debug(message, data) {
              if (this.debugMode) {
                console.log(`[Supabase] ${message}`, data || '');
              }
            }

            async request(endpoint, options = {}) {
              const url = `${this.baseUrl}/rest/v1/${endpoint}`;
              const config = { headers: this.headers, ...options };

              this.debug(`Making request to: ${endpoint}`, { method: config.method || 'GET' });

              for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {
                try {
                  const response = await fetch(url, config);
                  
                  if (!response.ok) {
                    const errorText = await response.text();
                    this.debug(`Request failed (attempt ${attempt}): ${response.status} - ${errorText}`);
                    
                    if (attempt === this.retryAttempts) {
                      throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }
                    
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    continue;
                  }
                  
                  this.connected = true;
                  this.updateConnectionStatus(true);
                  
                  if (response.status === 204) {
                    this.debug('Request successful (no content)');
                    return null;
                  }
                  
                  const text = await response.text();
                  const result = text ? JSON.parse(text) : null;
                  this.debug('Request successful', result);
                  return result;
                } catch (error) {
                  this.debug(`Request error (attempt ${attempt}):`, error);
                  
                  if (attempt === this.retryAttempts) {
                    this.connected = false;
                    this.updateConnectionStatus(false);
                    throw error;
                  }
                  
                  // Wait before retry
                  await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
              }
            }

            updateConnectionStatus(connected) {
              const event = new CustomEvent('supabaseConnectionChange', { 
                detail: { connected } 
              });
              window.dispatchEvent(event);
            }

            async testConnection() {
              this.debug('Testing database connection...');
              try {
                await this.request('comments?limit=1');
                this.debug('Connection test successful');
                return true;
              } catch (error) {
                this.debug('Connection test failed:', error);
                return false;
              }
            }

            // === COMMENT METHODS ===
            async getComments(pageId) {
              this.debug(`Fetching comments for page: ${pageId}`);
              try {
                const comments = await this.request(
                  `comments?page_id=eq.${encodeURIComponent(pageId)}&order=created_at.desc`
                );
                this.debug(`Retrieved ${comments?.length || 0} comments`);
                return comments || [];
              } catch (error) {
                this.debug('Failed to fetch comments:', error);
                return [];
              }
            }

            async saveFeedback(feedbackData) {
              this.debug('Saving feedback:', feedbackData);
              try {
                const feedback = {
                  page_id: feedbackData.page_id,
                  comment_type: 'feedback',
                  comment_text: feedbackData.comment_text,
                  selected_text: feedbackData.selected_text || '',
                  selection_type: feedbackData.selection_type || 'text',
                  session_id: this.getSessionId(),
                  user_agent: navigator.userAgent
                };

                const response = await fetch(`${this.baseUrl}/rest/v1/comments`, {
                  method: 'POST',
                  headers: {
                    ...this.headers,
                    'Prefer': 'return=representation'
                  },
                  body: JSON.stringify(feedback)
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                const result = await response.json();
                this.debug('Feedback saved successfully:', result);
                
                // Create archive when first comment is made
                if (feedbackData.createArchive) {
                  await this.createContentArchive(feedbackData.page_id, feedbackData.contentHtml);
                }
                
                const event = new CustomEvent('feedbackSaved', { 
                  detail: { feedback: result[0] || result } 
                });
                window.dispatchEvent(event);
                
                return result;
              } catch (error) {
                this.debug('Failed to save feedback:', error);
                throw error;
              }
            }

            async deleteFeedback(feedbackId) {
              this.debug(`Deleting feedback: ${feedbackId}`);
              try {
                const response = await fetch(`${this.baseUrl}/rest/v1/comments?id=eq.${feedbackId}`, {
                  method: 'DELETE',
                  headers: this.headers
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                this.debug('Feedback deleted successfully');
                
                const event = new CustomEvent('feedbackDeleted', { 
                  detail: { feedbackId } 
                });
                window.dispatchEvent(event);

                return true;
              } catch (error) {
                this.debug('Failed to delete feedback:', error);
                throw error;
              }
            }

            async clearAllFeedback() {
              this.debug('Clearing all feedback');
              try {
                const response = await fetch(`${this.baseUrl}/rest/v1/comments`, {
                  method: 'DELETE',
                  headers: this.headers
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                this.debug('All feedback cleared successfully');

                const event = new CustomEvent('allFeedbackCleared');
                window.dispatchEvent(event);

                return true;
              } catch (error) {
                this.debug('Failed to clear feedback:', error);
                throw error;
              }
            }

            // === ARCHIVE METHODS ===
            async createContentArchive(pageId, contentHtml) {
              this.debug(`Creating archive for page: ${pageId}`);
              try {
                const archiveData = {
                  page_id: pageId,
                  content_html: contentHtml,
                  archive_version: `v${Date.now()}`,
                  resolution_status: 'active',
                  session_id: this.getSessionId()
                };

                const result = await this.request('archived_content', {
                  method: 'POST',
                  body: JSON.stringify(archiveData)
                });

                this.debug('Archive created successfully:', result);
                return result;
              } catch (error) {
                this.debug('Failed to create archive:', error);
                throw error;
              }
            }

            async getArchives(pageId) {
              this.debug(`Fetching archives for page: ${pageId}`);
              try {
                const archives = await this.request(
                  `archived_content?page_id=eq.${encodeURIComponent(pageId)}&order=created_at.desc`
                );
                this.debug(`Retrieved ${archives?.length || 0} archives`);
                return archives || [];
              } catch (error) {
                this.debug('Failed to fetch archives:', error);
                return [];
              }
            }

            async deleteArchive(archiveId) {
              this.debug(`Deleting archive: ${archiveId}`);
              try {
                await this.request(`archived_content?id=eq.${archiveId}`, {
                  method: 'DELETE'
                });
                this.debug('Archive deleted successfully');
                return true;
              } catch (error) {
                this.debug('Failed to delete archive:', error);
                throw error;
              }
            }

            async markReviewComplete(pageId, resolutionNotes) {
              this.debug(`Marking review complete for page: ${pageId}`);
              try {
                // Update all archives for this page to resolved status
                await this.request(`archived_content?page_id=eq.${encodeURIComponent(pageId)}`, {
                  method: 'PATCH',
                  body: JSON.stringify({
                    resolution_status: 'resolved',
                    resolution_date: new Date().toISOString(),
                    reviewer_notes: resolutionNotes
                  })
                });

                this.debug('Review marked as complete');
                return true;
              } catch (error) {
                this.debug('Failed to mark review complete:', error);
                throw error;
              }
            }

            // === UTILITY METHODS ===
            getSessionId() {
              let sessionId = localStorage.getItem('reviewSessionId');
              if (!sessionId) {
                sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('reviewSessionId', sessionId);
              }
              return sessionId;
            }

            // Download archive as HTML file
            downloadArchive(archive) {
              const blob = new Blob([archive.content_html], { type: 'text/html' });
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `${archive.page_id}_${archive.archive_version}.html`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              window.URL.revokeObjectURL(url);
            }
          }

          // Initialize client
          window.supabaseClient = new SupabaseClient();
          EOF

      # Step 10: Create Main Application CSS
      - name: Create Main Application CSS
        run: |
          cat > ./site/css/style.css << 'EOF'
          /* Enhanced SPA CSS with Review Window System */
          * { margin: 0; padding: 0; box-sizing: border-box; }

          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6; display: flex; height: 100vh; width: 100%;
            overflow: hidden; color: #333; background-color: #f8f8f8;
          }

          .sidebar {
            width: 300px; background-color: #e0f7f7; padding: 15px;
            height: 100vh; overflow-y: auto; border-right: 1px solid #c0e0e0;
            display: flex; flex-direction: column; box-shadow: 2px 0 5px rgba(0,0,0,0.05);
          }

          .main-content {
            flex: 1; padding: 30px; height: 100vh; overflow-y: auto;
            background-color: #ffffff; position: relative;
          }

          .sidebar h2 {
            font-weight: 500; margin-bottom: 15px; color: #00747a;
            border-bottom: 2px solid #80cbc4; padding-bottom: 10px; font-size: 1.4em;
          }

          .sidebar-nav { flex: 1; overflow-y: auto; margin-top: 15px; }
          .sidebar ul { list-style-type: none; padding-left: 0; margin-bottom: 5px; }
          .sidebar ul ul { padding-left: 20px; margin-top: 5px; margin-bottom: 0; }
          .sidebar li { margin-bottom: 6px; position: relative; }

          .sidebar .toggle-arrow {
            display: inline-block; width: 18px; height: 18px;
            position: absolute; left: 0; top: 4px; cursor: pointer;
            z-index: 10; color: #00747a;
          }
          .sidebar .toggle-arrow:before {
            content: "▶"; display: inline-block; font-size: 10px;
            transition: transform 0.2s;
          }
          .sidebar li.expanded > .toggle-arrow:before { transform: rotate(90deg); }
          .sidebar li.has-children > ul { display: none; }
          .sidebar li.has-children.expanded > ul { display: block; }

          .sidebar a {
            color: #00747a; text-decoration: none; display: block;
            padding: 6px 5px 6px 22px; border-radius: 4px;
            transition: background-color 0.2s, color 0.2s; cursor: pointer; font-size: 0.95em;
          }
          .sidebar a:hover { background-color: #e1f5fe; color: #006064; }
          .sidebar a.active {
            background-color: #80deea; font-weight: bold; color: #006064;
            box-shadow: inset 3px 0 0 #00acc1;
          }

          /* Review Controls Section */
          .review-controls {
            border-top: 2px solid #80cbc4; padding-top: 15px; margin-top: 15px;
            display: flex; flex-direction: column; gap: 10px;
          }
          .review-controls h3 { 
            color: #00747a; font-size: 1.1em; margin-bottom: 10px; 
          }

          .feedback-instructions {
            background: #e8f5e8; border: 1px solid #c8e6c9; border-radius: 6px;
            padding: 12px; margin: 10px 0; font-size: 0.85em; color: #2e7d32;
          }
          .feedback-instructions h4 {
            margin: 0 0 8px 0; color: #1b5e20; font-size: 0.9em;
          }
          .feedback-instructions ul {
            margin: 5px 0; padding-left: 15px;
          }
          .feedback-instructions li {
            margin-bottom: 3px;
          }

          .search-container {
            margin-bottom: 15px; display: flex; gap: 5px; width: 100%;
          }
          .search-container input[type="text"] {
            flex-grow: 1; padding: 8px 10px; border: 1px solid #b0e0e6;
            border-radius: 5px; font-size: 0.9em; outline: none;
          }
          .search-container button {
            padding: 8px 10px; background-color: #00acc1; color: white;
            border: none; border-radius: 5px; cursor: pointer;
          }

          .search-results {
            list-style-type: none; padding: 0; margin-top: 15px;
            border-top: 1px solid #e0e0e0; padding-top: 10px;
            max-height: 300px; overflow-y: auto; background-color: #f5f9f9;
          }

          .main-content h1, .main-content h2, .main-content h3, .main-content h4 {
            font-weight: 500; margin-top: 1.5em; margin-bottom: 0.8em; color: #00838f;
          }
          .main-content h1 {
            font-size: 2em; border-bottom: 1px solid #e0e0e0;
            padding-bottom: 10px; margin-top: 0;
          }
          .main-content p { margin-bottom: 1em; line-height: 1.6; }
          .main-content img {
            max-width: 100%; height: auto; display: block; margin: 1em auto;
            border: 1px solid #e0e0e0; border-radius: 4px;
          }

          .welcome-screen {
            text-align: center; padding: 40px 20px; color: #00838f;
          }
          .welcome-screen h2 { margin-bottom: 20px; font-size: 2em; }

          /* Connection Status - Bottom left */
          .connection-status {
            position: fixed; bottom: 15px; left: 15px; z-index: 2000;
            padding: 8px 12px; border-radius: 20px; font-size: 0.8em;
            font-weight: bold; transition: all 0.3s; cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
          }
          .connection-status.connected { 
            background: #4caf50; color: white; 
          }
          .connection-status.disconnected { 
            background: #f44336; color: white; animation: pulse 2s infinite;
          }
          .connection-status.connecting { 
            background: #ff9800; color: white; 
          }

          @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
          }

          /* Review Window Button */
          .review-window-open-btn {
            position: fixed; top: 15px; right: 15px; z-index: 1500;
            padding: 12px 18px; background: #2196f3; color: white; border: none;
            border-radius: 6px; cursor: pointer; font-size: 1em; font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: all 0.3s;
            display: flex; align-items: center; gap: 8px;
          }
          .review-window-open-btn:hover { 
            background: #1976d2; transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
          }
          .review-window-open-btn::before {
            content: "🔍"; font-size: 1.2em;
          }

          /* Responsive */
          @media (max-width: 1200px) {
            .sidebar { width: 280px; }
          }

          @media (max-width: 768px) {
            body { flex-direction: column; height: auto; }
            .sidebar { width: 100%; height: auto; max-height: 40vh; }
            .main-content { height: auto; min-height: 60vh; }
            .connection-status { position: relative; margin-bottom: 10px; }
          }
          EOF

      # Step 11: Create Fixed Review Window CSS with Space Optimization
      - name: Create Fixed Review Window CSS with Space Optimization
        run: |
          cat > ./site/css/review-window.css << 'EOF'
          /* Space-Optimized Review Window with Fixed Hover and Click-to-Scroll */
          * { margin: 0; padding: 0; box-sizing: border-box; }

          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.4; display: flex; height: 100vh; width: 100%;
            overflow: hidden; color: #333; background-color: #fffbf0;
          }

          /* Compact Review Header */
          .review-header {
            position: fixed; top: 0; left: 0; right: 0; z-index: 2000;
            background: linear-gradient(135deg, #2c5aa0, #1e3f73); color: white;
            padding: 10px 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex; justify-content: space-between; align-items: center;
            height: 50px;
          }

          .review-title {
            font-size: 1.1em; font-weight: 600; display: flex; align-items: center; gap: 8px;
          }
          .review-title::before { content: "🔍"; font-size: 1.2em; }

          .review-actions {
            display: flex; gap: 6px; align-items: center;
          }

          .review-btn {
            padding: 6px 12px; border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1); color: white; border-radius: 4px;
            cursor: pointer; font-size: 0.85em; transition: all 0.3s;
            display: flex; align-items: center; gap: 4px;
          }
          .review-btn:hover {
            background: rgba(255,255,255,0.2); transform: translateY(-1px);
          }
          .review-btn.success {
            background: #4caf50; border-color: #4caf50;
          }
          .review-btn.success:hover { background: #45a049; }
          .review-btn.danger {
            background: #f44336; border-color: #f44336;
          }
          .review-btn.danger:hover { background: #da190b; }
          .review-btn.close {
            background: #ff9800; border-color: #ff9800;
          }
          .review-btn.close:hover { background: #f57c00; }

          /* Optimized Review Layout */
          .review-layout {
            display: flex; height: 100vh; padding-top: 50px;
          }

          .document-panel {
            flex: 1; padding: 15px 20px; overflow-y: auto; background: #ffffff;
            border-right: 1px solid #e0e0e0;
          }

          .feedback-panel {
            width: 280px; background: #f8f9fa; padding: 12px;
            overflow-y: auto; border-left: 1px solid #e0e0e0;
            display: flex; flex-direction: column;
          }

          /* Compact Document Content Styles */
          .document-content {
            max-width: none; margin: 0;
          }

          .document-content h1, .document-content h2, .document-content h3, .document-content h4 {
            font-weight: 500; margin-top: 1.2em; margin-bottom: 0.6em; color: #00838f;
          }
          .document-content h1 {
            font-size: 1.8em; border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px; margin-top: 0;
          }
          .document-content p { 
            margin-bottom: 0.8em; line-height: 1.5;
          }
          .document-content img {
            max-width: 100%; height: auto; display: block; margin: 0.8em auto;
            border: 1px solid #e0e0e0; border-radius: 4px;
          }

          .document-content ul, .document-content ol {
            margin-bottom: 0.8em; padding-left: 1.5em;
          }
          .document-content li {
            margin-bottom: 0.3em;
          }

          /* Enhanced Reviewable Text with Hover */
          .reviewable-text { 
            cursor: text; user-select: text; position: relative;
            transition: background-color 0.2s;
          }
          .reviewable-text:hover {
            background-color: rgba(255, 235, 59, 0.1); border-radius: 2px;
          }

          /* Fixed Feedback Highlights with Working Hover Tooltips */
          .review-feedback-highlight {
            background-color: #e3f2fd; border-left: 2px solid #2196f3;
            padding: 1px 3px; margin: 1px 0; border-radius: 2px;
            cursor: pointer; position: relative; display: inline;
            transition: all 0.2s ease;
          }

          .review-feedback-highlight:hover {
            background-color: #bbdefb; border-left-color: #1976d2;
          }

          /* Working Hover Tooltips */
          .feedback-tooltip {
            position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 6px 8px; border-radius: 4px;
            font-size: 0.75em; white-space: nowrap; z-index: 3000;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
            max-width: 250px; white-space: normal; text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            margin-bottom: 5px;
          }

          .feedback-tooltip:after {
            content: ''; position: absolute; top: 100%; left: 50%;
            transform: translateX(-50%); border: 5px solid transparent;
            border-top-color: #333;
          }

          .review-feedback-highlight:hover .feedback-tooltip {
            opacity: 1; pointer-events: auto;
          }

          /* Compact Feedback Panel Styles */
          .feedback-panel h3 {
            color: #333; margin-bottom: 12px; padding-bottom: 6px;
            border-bottom: 1px solid #e0e0e0; font-size: 1.1em; font-weight: 600;
          }

          .feedback-list {
            flex: 1; overflow-y: auto;
          }

          .feedback-group {
            background: white; border: 1px solid #e0e0e0; border-radius: 6px;
            margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden; border-left: 3px solid #2196f3;
            cursor: pointer; transition: all 0.2s ease;
          }

          .feedback-group:hover {
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            transform: translateY(-1px);
          }

          .selected-text-header {
            background: #f8f9fa; padding: 8px 10px; border-bottom: 1px solid #e9ecef;
            font-weight: 500; color: #495057; font-size: 0.85em;
          }

          .selected-text-content {
            font-style: italic; background: #e9ecef; padding: 6px 8px;
            border-radius: 3px; margin-top: 6px; font-size: 0.8em;
            border-left: 2px solid #6c757d; color: #495057;
            word-wrap: break-word; overflow-wrap: break-word;
            line-height: 1.3;
          }

          .feedback-details {
            padding: 10px;
          }

          .feedback-meta {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 6px; font-size: 0.75em; color: #6c757d;
          }

          .feedback-type-badge {
            padding: 2px 6px; border-radius: 10px; font-size: 0.7em;
            font-weight: bold; text-transform: uppercase;
            background: #e3f2fd; color: #1976d2;
          }

          .feedback-text {
            margin: 6px 0; line-height: 1.4; font-size: 0.9em; color: #333;
            word-wrap: break-word; overflow-wrap: break-word;
          }

          .feedback-actions {
            display: flex; gap: 6px; margin-top: 8px; padding-top: 6px;
            border-top: 1px solid #f0f0f0;
          }

          .feedback-btn {
            padding: 3px 8px; border: 1px solid #ddd; border-radius: 3px;
            background: #f8f9fa; cursor: pointer; font-size: 0.75em;
            transition: all 0.2s; display: flex; align-items: center; gap: 3px;
          }
          .feedback-btn:hover { 
            background: #e9ecef; transform: translateY(-1px);
          }
          .feedback-btn.delete { 
            border-color: #dc3545; color: #dc3545; 
          }
          .feedback-btn.delete:hover { 
            background: #dc3545; color: white; 
          }

          .no-feedback {
            text-align: center; color: #6c757d; font-style: italic; 
            padding: 20px 15px; background: white; border-radius: 6px;
            border: 1px dashed #dee2e6; font-size: 0.9em;
          }

          /* Compact Feedback Dialog */
          .dialog-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.5); z-index: 2999; display: none;
            animation: fadeIn 0.2s ease-out;
          }
          .dialog-overlay.show { display: block; }

          @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
          }

          .feedback-dialog {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; border: 2px solid #2c5aa0; border-radius: 6px;
            padding: 15px; width: 400px; max-width: 90vw; z-index: 3000;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3); display: none;
            animation: slideIn 0.3s ease-out;
          }
          .feedback-dialog.show { display: block; }

          @keyframes slideIn {
            from { transform: translate(-50%, -60%); opacity: 0; }
            to { transform: translate(-50%, -50%); opacity: 1; }
          }

          .feedback-dialog h3 { 
            color: #2c5aa0; margin-bottom: 10px; font-size: 1.1em;
          }
          .feedback-dialog textarea {
            width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd;
            border-radius: 4px; font-family: inherit; resize: vertical;
            font-size: 0.9em;
          }

          .dialog-actions {
            display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px;
          }
          .dialog-btn {
            padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px;
            cursor: pointer; font-size: 0.85em; transition: all 0.2s;
          }
          .dialog-btn.primary {
            background: #2c5aa0; color: white; border-color: #2c5aa0;
          }
          .dialog-btn.primary:hover {
            background: #1e3f73; border-color: #1e3f73;
          }
          .dialog-btn.secondary { 
            background: #f5f5f5; 
          }
          .dialog-btn.secondary:hover { 
            background: #e0e0e0; 
          }

          /* Responsive Optimizations */
          @media (max-width: 1400px) {
            .feedback-panel { width: 260px; }
          }

          @media (max-width: 1200px) {
            .document-panel { padding: 12px 15px; }
            .feedback-panel { width: 240px; padding: 10px; }
          }

          @media (max-width: 1000px) {
            .review-layout { flex-direction: column; }
            .document-panel { height: 60%; border-right: none; border-bottom: 1px solid #e0e0e0; }
            .feedback-panel { width: 100%; height: 40%; border-left: none; }
          }
          EOF

      # Step 12: Create Enhanced Main SPA JavaScript
      - name: Create Enhanced Main SPA JavaScript
        run: |
          cat > ./site/js/app.js << 'EOF'
          // Enhanced SPA Application with Fixed Review Window System

          // === INITIALIZATION AND STATE ===
          const DEBUG_MODE = true;
          const debug = (message, data) => {
            if (DEBUG_MODE) console.log(`[DITA-SPA] ${message}`, data || '');
          };

          // DOM Elements
          const contentEl = document.getElementById('content');
          const contentTitleEl = document.getElementById('content-title');
          const navigationEl = document.getElementById('navigation');
          const searchInput = document.getElementById('searchInput');
          const searchButton = document.getElementById('searchButton');
          const searchResultsEl = document.getElementById('searchResults');

          // Application State
          const getBasePath = () => {
            if (location.hostname.includes('github.io')) {
              const pathSegments = location.pathname.split('/');
              if (pathSegments.length > 1) return '/' + pathSegments[1];
            }
            return '';
          };

          window.currentPage = null;
          window.reviewMode = false;
          window.currentSelection = null;
          window.feedback = {};
          window.archives = {};
          const basePath = getBasePath();
          let connectionStatus = 'connecting';
          let reviewWindow = null;

          // === CONNECTION MANAGEMENT ===
          function createConnectionStatus() {
            const statusEl = document.createElement('div');
            statusEl.id = 'connectionStatus';
            statusEl.className = 'connection-status connecting';
            statusEl.innerHTML = '🔄 Connecting...';
            statusEl.title = 'Click to test connection';
            statusEl.addEventListener('click', testConnection);
            document.body.appendChild(statusEl);
            debug('Connection status indicator created');
            return statusEl;
          }

          function updateConnectionStatus(connected, message) {
            let statusEl = document.getElementById('connectionStatus');
            if (!statusEl) statusEl = createConnectionStatus();
            
            if (connected) {
              statusEl.className = 'connection-status connected';
              statusEl.innerHTML = '🟢 Database Connected';
              statusEl.title = 'Database connection active - Click to refresh';
              connectionStatus = 'connected';
              debug('Connection status: Connected');
            } else {
              statusEl.className = 'connection-status disconnected';
              statusEl.innerHTML = '🔴 Database Offline';
              statusEl.title = 'Database connection failed - Click to retry';
              connectionStatus = 'disconnected';
              debug('Connection status: Disconnected');
            }
          }

          async function testConnection() {
            const statusEl = document.getElementById('connectionStatus');
            if (statusEl) {
              statusEl.className = 'connection-status connecting';
              statusEl.innerHTML = '🔄 Testing...';
            }
            
            try {
              const connected = await window.supabaseClient.testConnection();
              updateConnectionStatus(connected);
              return connected;
            } catch (error) {
              debug('Connection test error:', error);
              updateConnectionStatus(false);
              return false;
            }
          }

          // === REVIEW WINDOW SYSTEM ===
          function createReviewButton() {
            const reviewBtn = document.createElement('button');
            reviewBtn.className = 'review-window-open-btn';
            reviewBtn.id = 'openReviewWindow';
            reviewBtn.innerHTML = 'Review Mode';
            reviewBtn.title = 'Open dedicated review window for this document';
            reviewBtn.addEventListener('click', openReviewWindow);
            document.body.appendChild(reviewBtn);
            debug('Review window button created');
            return reviewBtn;
          }

          async function openReviewWindow() {
            if (!window.currentPage) {
              alert('Please select a document first before opening review mode.');
              return;
            }

            if (reviewWindow && !reviewWindow.closed) {
              reviewWindow.focus();
              return;
            }

            debug(`Opening review window for page: ${window.currentPage}`);

            try {
              // Get current content
              const currentContent = contentEl.innerHTML;
              const currentTitle = contentTitleEl.textContent;
              
              // Load feedback and archives for this page
              const feedback = await window.supabaseClient.getComments(window.currentPage);
              const archives = await window.supabaseClient.getArchives(window.currentPage);

              // Open review window
              reviewWindow = window.open('', 'ReviewWindow', 
                'width=1400,height=900,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=no,status=no'
              );

              if (!reviewWindow) {
                alert('Please allow popups to open the review window.');
                return;
              }

              // Create review window content
              reviewWindow.document.write(createReviewWindowHTML(currentTitle, currentContent, feedback, archives));
              reviewWindow.document.close();

              // Initialize review window functionality
              initializeReviewWindow(reviewWindow, feedback, archives);

              debug('Review window opened successfully');

            } catch (error) {
              debug('Error opening review window:', error);
              alert('Failed to open review window. Please check your connection.');
            }
          }

          function createReviewWindowHTML(title, content, feedback, archives) {
            return `
              <!DOCTYPE html>
              <html lang="en">
              <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Review: ${title}</title>
                <link rel="stylesheet" href="${basePath}/css/review-window.css">
                <script src="${basePath}/js/supabase-config.js"></script>
              </head>
              <body>
                <div class="review-header">
                  <div class="review-title">Review Mode: ${title}</div>
                  <div class="review-actions">
                    <button class="review-btn success" onclick="completeReview()">✅ Complete Review</button>
                    <button class="review-btn danger" onclick="clearAllReview()">🗑️ Clear All</button>
                    <button class="review-btn close" onclick="window.close()">✕ Close</button>
                  </div>
                </div>

                <div class="review-layout">
                  <div class="document-panel">
                    <div class="document-content" id="documentContent">
                      ${content}
                    </div>
                  </div>

                  <div class="feedback-panel">
                    <h3>💬 Document Feedback</h3>
                    <div class="feedback-list" id="feedbackList">
                      <div class="no-feedback">
                        <p>No feedback yet.</p>
                        <p>Select text in the document to leave feedback.</p>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Feedback Dialog -->
                <div class="dialog-overlay" id="dialogOverlay"></div>
                <div class="feedback-dialog" id="feedbackDialog">
                  <h3>📝 Leave Feedback</h3>
                  <div style="margin: 15px 0;">
                    <textarea id="feedbackText" placeholder="Enter your feedback about the selected text..."></textarea>
                  </div>
                  <div class="dialog-actions">
                    <button class="dialog-btn secondary" onclick="closeFeedbackDialog()">Cancel</button>
                    <button class="dialog-btn primary" onclick="saveFeedback()">Save Feedback</button>
                  </div>
                </div>

                <script>
                  // Review window global variables
                  window.currentPage = '${window.currentPage}';
                  window.currentSelection = null;
                  window.parentWindow = window.opener;
                  window.feedbackHighlights = new Map(); // Track highlights with their feedback
                  
                  // Initialize review window
                  document.addEventListener('DOMContentLoaded', function() {
                    initializeReviewWindow();
                  });
                </script>
              </body>
              </html>
            `;
          }

          function initializeReviewWindow(reviewWin, feedback, archives) {
            // Pass comprehensive initialization script to review window
            reviewWin.eval(`
              // Enhanced Review Window Initialization Script
              const DEBUG_MODE = true;
              const debug = (message, data) => {
                if (DEBUG_MODE) console.log('[Review Window] ' + message, data || '');
              };

              // Initialize review functionality
              function initializeReviewWindow() {
                debug('Initializing enhanced review window functionality');
                
                // Make all text elements reviewable
                const contentEl = document.getElementById('documentContent');
                const textElements = contentEl.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, div');
                
                textElements.forEach(element => {
                  if (element.children.length === 0 || element.textContent.trim()) {
                    element.classList.add('reviewable-text');
                    element.addEventListener('mouseup', handleTextSelection);
                  }
                });

                // Load existing feedback and create highlights
                loadFeedback();
                
                debug('Review window initialization complete');
              }

              function handleTextSelection(event) {
                const selection = window.getSelection();
                if (selection.toString().trim().length === 0) return;
                
                const selectedText = selection.toString().trim();
                if (selectedText.length < 3) return;
                
                debug('Text selected in review window:', selectedText);
                
                window.currentSelection = {
                  type: 'text',
                  text: selectedText,
                  element: event.target
                };
                
                showFeedbackDialog();
              }

              function showFeedbackDialog() {
                const dialog = document.getElementById('feedbackDialog');
                const overlay = document.getElementById('dialogOverlay');
                
                if (dialog && overlay) {
                  dialog.classList.add('show');
                  overlay.classList.add('show');
                  
                  const selectedText = window.currentSelection?.text || '';
                  if (selectedText) {
                    const textArea = document.getElementById('feedbackText');
                    textArea.placeholder = 'Leave feedback about: "' + selectedText.substring(0, 50) + (selectedText.length > 50 ? '...' : '') + '"';
                  }
                  
                  document.getElementById('feedbackText').focus();
                }
              }

              function closeFeedbackDialog() {
                const dialog = document.getElementById('feedbackDialog');
                const overlay = document.getElementById('dialogOverlay');
                
                if (dialog && overlay) {
                  dialog.classList.remove('show');
                  overlay.classList.remove('show');
                  document.getElementById('feedbackText').value = '';
                  document.getElementById('feedbackText').placeholder = 'Enter your feedback about the selected text...';
                }
                
                window.getSelection().removeAllRanges();
                window.currentSelection = null;
              }

              async function saveFeedback() {
                if (!window.currentSelection) {
                  closeFeedbackDialog();
                  return;
                }
                
                const feedbackText = document.getElementById('feedbackText').value.trim();
                
                if (!feedbackText) {
                  alert('Please enter your feedback.');
                  return;
                }
                
                try {
                  const feedbackData = {
                    page_id: window.currentPage,
                    comment_text: feedbackText,
                    selected_text: window.currentSelection.text,
                    selection_type: 'text'
                  };
                  
                  debug('Saving feedback from review window:', feedbackData);
                  
                  const result = await window.supabaseClient.saveFeedback(feedbackData);
                  debug('Feedback saved successfully:', result);
                  
                  const saveBtn = document.querySelector('.dialog-btn.primary');
                  const originalText = saveBtn.textContent;
                  saveBtn.textContent = '✓ Saved!';
                  saveBtn.style.background = '#4caf50';
                  
                  setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '';
                    closeFeedbackDialog();
                    loadFeedback(); // Refresh feedback display
                  }, 1000);
                  
                } catch (error) {
                  debug('Error saving feedback:', error);
                  alert('Failed to save feedback. Please check your connection and try again.');
                }
              }

              async function loadFeedback() {
                try {
                  debug('Loading feedback for review window');
                  const feedback = await window.supabaseClient.getComments(window.currentPage);
                  displayFeedback(feedback);
                  createTextHighlights(feedback);
                } catch (error) {
                  debug('Failed to load feedback:', error);
                }
              }

              function createTextHighlights(feedbackItems) {
                if (!feedbackItems || feedbackItems.length === 0) return;

                const contentEl = document.getElementById('documentContent');
                
                feedbackItems.forEach(item => {
                  if (item.selected_text && item.selected_text.trim()) {
                    highlightTextInDocument(contentEl, item.selected_text, item);
                  }
                });
              }

              function highlightTextInDocument(container, selectedText, feedbackItem) {
                const walker = document.createTreeWalker(
                  container,
                  NodeFilter.SHOW_TEXT,
                  null,
                  false
                );
                
                let node;
                while (node = walker.nextNode()) {
                  const text = node.textContent;
                  const index = text.toLowerCase().indexOf(selectedText.toLowerCase());
                  
                  if (index !== -1 && !node.parentNode.classList.contains('review-feedback-highlight')) {
                    const parent = node.parentNode;
                    const beforeText = text.substring(0, index);
                    const actualText = text.substring(index, index + selectedText.length);
                    const afterText = text.substring(index + selectedText.length);
                    
                    // Create highlight span
                    const span = document.createElement('span');
                    span.className = 'review-feedback-highlight';
                    span.setAttribute('data-feedback-id', feedbackItem.id);
                    span.textContent = actualText;
                    
                    // Create tooltip
                    const tooltip = document.createElement('div');
                    tooltip.className = 'feedback-tooltip';
                    tooltip.textContent = feedbackItem.comment_text.substring(0, 100) + 
                      (feedbackItem.comment_text.length > 100 ? '...' : '');
                    span.appendChild(tooltip);
                    
                    // Replace text node
                    parent.removeChild(node);
                    if (beforeText) parent.appendChild(document.createTextNode(beforeText));
                    parent.appendChild(span);
                    if (afterText) parent.appendChild(document.createTextNode(afterText));
                    
                    // Store highlight reference
                    window.feedbackHighlights.set(feedbackItem.id, span);
                    
                    break;
                  }
                }
              }

              function displayFeedback(feedbackItems) {
                const feedbackListEl = document.getElementById('feedbackList');
                if (!feedbackListEl) return;
                
                if (!feedbackItems || feedbackItems.length === 0) {
                  feedbackListEl.innerHTML = '<div class="no-feedback"><p>No feedback yet.</p><p>Select text in the document to leave feedback.</p></div>';
                  return;
                }
                
                // Group feedback by selected text
                const groupedFeedback = {};
                feedbackItems.forEach(item => {
                  if (!item || !item.comment_text) return;
                  
                  const key = item.selected_text && item.selected_text.trim() ? 
                             item.selected_text.trim() : 'General';
                  if (!groupedFeedback[key]) {
                    groupedFeedback[key] = [];
                  }
                  groupedFeedback[key].push(item);
                });
                
                let feedbackHtml = '';
                
                Object.keys(groupedFeedback).forEach(selectedText => {
                  const feedbackGroup = groupedFeedback[selectedText];
                  
                  feedbackHtml += '<div class="feedback-group" onclick="scrollToHighlight(' + feedbackGroup[0].id + ')">';
                  
                  if (selectedText !== 'General') {
                    feedbackHtml += '<div class="selected-text-header">📝 Selected Text:<div class="selected-text-content">"' + escapeHtml(selectedText) + '"</div></div>';
                  }
                  
                  feedbackGroup.forEach(item => {
                    feedbackHtml += '<div class="feedback-details">';
                    feedbackHtml += '<div class="feedback-meta">';
                    feedbackHtml += '<span class="feedback-type-badge">💬 feedback</span>';
                    feedbackHtml += '<span class="feedback-date">' + formatDate(item.created_at) + '</span>';
                    feedbackHtml += '</div>';
                    feedbackHtml += '<div class="feedback-text">' + escapeHtml(item.comment_text) + '</div>';
                    feedbackHtml += '<div class="feedback-actions">';
                    feedbackHtml += '<button class="feedback-btn delete" onclick="event.stopPropagation(); deleteFeedback(' + item.id + ')">🗑️ Delete</button>';
                    feedbackHtml += '</div>';
                    feedbackHtml += '</div>';
                  });
                  
                  feedbackHtml += '</div>';
                });
                
                feedbackListEl.innerHTML = feedbackHtml;
              }

              // NEW: Click-to-scroll functionality
              function scrollToHighlight(feedbackId) {
                debug('Scrolling to highlight for feedback ID:', feedbackId);
                const highlight = window.feedbackHighlights.get(feedbackId);
                
                if (highlight) {
                  // Scroll to the highlight
                  highlight.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center',
                    inline: 'center'
                  });
                  
                  // Temporarily emphasize the highlight
                  highlight.style.backgroundColor = '#ffeb3b';
                  highlight.style.borderLeft = '3px solid #f57c00';
                  highlight.style.transform = 'scale(1.05)';
                  
                  setTimeout(() => {
                    highlight.style.backgroundColor = '#e3f2fd';
                    highlight.style.borderLeft = '2px solid #2196f3';
                    highlight.style.transform = 'scale(1)';
                  }, 2000);
                } else {
                  debug('Highlight not found for feedback ID:', feedbackId);
                  // Try to find any highlight with the same feedback ID
                  const highlightElement = document.querySelector('[data-feedback-id="' + feedbackId + '"]');
                  if (highlightElement) {
                    highlightElement.scrollIntoView({ 
                      behavior: 'smooth', 
                      block: 'center' 
                    });
                  }
                }
              }

              async function deleteFeedback(feedbackId) {
                if (!confirm('Are you sure you want to delete this feedback?')) return;
                
                try {
                  debug('Deleting feedback from review window:', feedbackId);
                  await window.supabaseClient.deleteFeedback(feedbackId);
                  
                  // Remove highlight from document
                  const highlight = window.feedbackHighlights.get(feedbackId);
                  if (highlight) {
                    const parent = highlight.parentNode;
                    parent.insertBefore(document.createTextNode(highlight.textContent), highlight);
                    parent.removeChild(highlight);
                    window.feedbackHighlights.delete(feedbackId);
                  }
                  
                  await loadFeedback();
                } catch (error) {
                  debug('Delete feedback error:', error);
                  alert('Failed to delete feedback. Please check your connection and try again.');
                }
              }

              async function completeReview() {
                const resolutionNotes = prompt('Enter resolution notes (optional):') || '';
                
                try {
                  debug('Marking review complete from review window');
                  await window.supabaseClient.markReviewComplete(window.currentPage, resolutionNotes);
                  alert('Review marked as complete! All feedback has been resolved and archived.');
                  if (window.parentWindow) {
                    window.parentWindow.postMessage({ type: 'reviewCompleted', pageId: window.currentPage }, '*');
                  }
                } catch (error) {
                  debug('Error completing review:', error);
                  alert('Failed to complete review. Please check your connection and try again.');
                }
              }

              async function clearAllReview() {
                if (!confirm('Are you sure you want to clear ALL feedback for this document? This cannot be undone.')) return;
                
                try {
                  debug('Clearing all review data from review window');
                  await window.supabaseClient.clearAllFeedback();
                  
                  // Clear all highlights
                  window.feedbackHighlights.forEach((highlight, id) => {
                    const parent = highlight.parentNode;
                    parent.insertBefore(document.createTextNode(highlight.textContent), highlight);
                    parent.removeChild(highlight);
                  });
                  window.feedbackHighlights.clear();
                  
                  await loadFeedback();
                  alert('All feedback has been cleared successfully.');
                } catch (error) {
                  debug('Error clearing review data:', error);
                  alert('Failed to clear review data. Please check your connection and try again.');
                }
              }

              // Utility functions
              function formatDate(dateString) {
                const date = new Date(dateString);
                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
              }

              function escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
              }

              // Dialog overlay click handler
              document.getElementById('dialogOverlay').addEventListener('click', closeFeedbackDialog);
            `);
          }

          // === NAVIGATION SYSTEM ===
          function renderNavigation(items, parentEl = navigationEl) {
            const ul = document.createElement('ul');
            ul.setAttribute('role', 'menu');

            items.forEach(item => {
              const li = document.createElement('li');
              li.setAttribute('role', 'presentation');

              if (item.children && item.children.length > 0) {
                li.classList.add('has-children');
                const toggle = document.createElement('span');
                toggle.className = 'toggle-arrow';
                toggle.addEventListener('click', (e) => {
                  e.stopPropagation();
                  li.classList.toggle('expanded');
                });
                li.appendChild(toggle);
              }

              const a = document.createElement('a');
              a.setAttribute('role', 'menuitem');
              a.textContent = item.title;
              a.setAttribute('data-id', item.id);
              a.href = `#${item.id}`;

              a.addEventListener('click', (e) => {
                e.preventDefault();
                if (item.children && item.children.length > 0) {
                  li.classList.toggle('expanded');
                }
                navigateToPage(item.id);
                if (searchResultsEl) searchResultsEl.innerHTML = '';
                if (searchInput) searchInput.value = '';
              });

              li.appendChild(a);
              if (item.children && item.children.length > 0) {
                renderNavigation(item.children, li);
              }
              ul.appendChild(li);
            });

            parentEl.appendChild(ul);
          }

          function navigateToPage(pageId, pushState = true) {
            debug(`Navigating to page: ${pageId}`);
            
            if (!pageId) {
              showErrorContent('undefined');
              return;
            }

            updateActiveNavItem(pageId);
            expandNavigationTo(pageId);

            if (pushState) {
              history.pushState({ pageId }, '', `#${pageId}`);
            }

            document.body.classList.add('loading');
            window.currentPage = pageId;

            loadContent(pageId)
              .then(content => {
                const title = getPageTitle(pageId);
                contentTitleEl.textContent = title;
                document.title = title;
                contentEl.innerHTML = content;
                
                document.body.classList.remove('loading');
                debug(`Content loaded successfully for: ${pageId}`);
              })
              .catch(error => {
                debug(`Content load error for ${pageId}:`, error);
                showErrorContent(pageId);
              });
          }

          async function loadContent(pageId) {
            const contentPath = `${basePath}/content/${pageId}.html`;
            debug(`Fetching content from: ${contentPath}`);

            try {
              const response = await fetch(contentPath);
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              return await response.text();
            } catch (error) {
              debug(`Content fetch error: ${error.message}`);
              throw error;
            }
          }

          function updateActiveNavItem(pageId) {
            const allNavItems = document.querySelectorAll('.sidebar a');
            allNavItems.forEach(item => item.classList.remove('active'));

            const activeItem = document.querySelector(`.sidebar a[data-id="${pageId}"]`);
            if (activeItem) {
              activeItem.classList.add('active');
              let parent = activeItem.parentElement;
              while (parent && !parent.classList.contains('sidebar')) {
                if (parent.classList.contains('has-children')) {
                  parent.classList.add('expanded');
                }
                parent = parent.parentElement;
              }
            }
          }

          function expandNavigationTo(pageId) {
            function findPageInNavigation(items, id, path = []) {
              for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const currentPath = [...path, item];
                if (item.id === id) return currentPath;
                if (item.children && item.children.length > 0) {
                  const result = findPageInNavigation(item.children, id, currentPath);
                  if (result) return result;
                }
              }
              return null;
            }

            const path = findPageInNavigation(navigationConfig, pageId);
            if (!path) return;

            for (let i = 0; i < path.length - 1; i++) {
              const item = path[i];
              const li = document.querySelector(`.sidebar li a[data-id="${item.id}"]`).parentElement;
              li.classList.add('expanded');
            }
          }

          function handlePopState(event) {
            const pageId = event.state?.pageId || getPageIdFromUrl() || navigationConfig[0]?.id;
            debug(`Popstate event, loading page: ${pageId}`);
            navigateToPage(pageId, false);
          }

          function getPageIdFromUrl() {
            return window.location.hash.substring(1) || null;
          }

          function getPageTitle(pageId) {
            if (window.contentIdMap && contentIdMap[pageId]) {
              return contentIdMap[pageId].title;
            }

            function findTitleInNav(items, id) {
              for (const item of items) {
                if (item.id === id) return item.title;
                if (item.children && item.children.length > 0) {
                  const title = findTitleInNav(item.children, id);
                  if (title) return title;
                }
              }
              return null;
            }

            const navTitle = findTitleInNav(navigationConfig, pageId);
            if (navTitle) return navTitle;

            return pageId.split(/-|_/).map(word =>
              word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
          }

          function showErrorContent(pageId) {
            debug(`Showing error content for: ${pageId}`);
            contentEl.innerHTML = `
              <div class="error">
                <h2>Content Not Found</h2>
                <p>The requested content "${pageId}" could not be loaded.</p>
                <p>Please select another topic from the navigation menu.</p>
              </div>
            `;
            document.body.classList.remove('loading');
          }

          function showWelcomeScreen() {
            contentTitleEl.textContent = 'Automotive Documentation';
            document.title = 'Automotive Documentation';
            contentEl.innerHTML = `
              <div class="welcome-screen">
                <h2>Welcome to Enhanced Automotive Documentation</h2>
                <p>Select a topic from the navigation menu to begin.</p>
                <div style="margin-top: 30px; padding: 20px; background: #f0f8ff; border-radius: 8px; border-left: 4px solid #2196f3;">
                  <h3>🔍 Enhanced Review System Features:</h3>
                  <ul style="text-align: left; margin-top: 15px;">
                    <li><strong>Dedicated Review Window:</strong> Click "Review Mode" to open specialized review interface</li>
                    <li><strong>Side-by-Side Review:</strong> Document content alongside feedback panel</li>
                    <li><strong>Text Selection Feedback:</strong> Select any text to leave contextual comments</li>
                    <li><strong>Hover Tooltips:</strong> Hover over highlighted text to see feedback previews</li>
                    <li><strong>Click-to-Scroll:</strong> Click feedback items to scroll to highlighted text</li>
                    <li><strong>Real-time Sync:</strong> All feedback syncs across windows and sessions</li>
                    <li><strong>Space-Optimized:</strong> Compact design maximizes screen real estate</li>
                  </ul>
                </div>
                <div style="margin-top: 20px; font-size: 0.9em; color: #666;">
                  <p>Connection Status: Check the indicator in the bottom-left corner</p>
                  <p>Review Mode: Click the blue "Review Mode" button in the top-right when viewing a document</p>
                </div>
              </div>
            `;
            document.body.classList.remove('loading');
          }

          // === SEARCH FUNCTIONALITY ===
          function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchResultsEl.innerHTML = '';

            if (query.length < 2) {
              if (query.length > 0) {
                searchResultsEl.innerHTML = '<li><p>Please enter at least 2 characters to search.</p></li>';
              }
              return;
            }

            debug(`Performing search for: ${query}`);
            const results = [];
            
            for (const id in contentIdMap) {
              if (contentIdMap.hasOwnProperty(id) && id !== 'default') {
                const item = contentIdMap[id];
                const title = item.title.toLowerCase();
                const content = item.content ? item.content.toLowerCase() : '';

                let snippet = '';
                let matchCount = 0;

                if (title.includes(query)) {
                  matchCount += 10;
                  snippet = `Found in title: "${highlightMatch(item.title, query)}"`;
                }

                const contentMatches = content.split(query).length - 1;
                if (contentMatches > 0) {
                  matchCount += contentMatches;
                  const matchIndex = content.indexOf(query);
                  const start = Math.max(0, matchIndex - 50);
                  const end = Math.min(content.length, matchIndex + query.length + 50);
                  const context = item.content.substring(start, end);
                  snippet += (snippet ? '<br>' : '') + `...${highlightMatch(context, query)}...`;
                }

                if (matchCount > 0) {
                  results.push({ id: id, title: item.title, snippet: snippet, score: matchCount });
                }
              }
            }

            results.sort((a, b) => b.score - a.score);

            if (results.length === 0) {
              searchResultsEl.innerHTML = '<li><p>No results found for your query.</p></li>';
            } else {
              results.forEach(result => {
                const li = document.createElement('li');
                const link = document.createElement('a');
                link.href = `#${result.id}`;
                link.textContent = result.title;
                link.addEventListener('click', (e) => {
                  e.preventDefault();
                  navigateToPage(result.id);
                  searchResultsEl.innerHTML = '';
                  searchInput.value = '';
                });
                
                li.appendChild(link);
                if (result.snippet) {
                  const p = document.createElement('p');
                  p.innerHTML = result.snippet;
                  li.appendChild(p);
                }
                searchResultsEl.appendChild(li);
              });
            }
          }

          function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<span style="background: yellow;">$1</span>');
          }

          // === EVENT LISTENERS ===
          function setupEventListeners() {
            window.addEventListener('popstate', handlePopState);
            
            // Supabase event listeners
            window.addEventListener('supabaseConnectionChange', (e) => {
              updateConnectionStatus(e.detail.connected);
            });

            // Message handling for review window communication
            window.addEventListener('message', (event) => {
              if (event.data.type === 'reviewCompleted') {
                debug('Review completed message received from review window');
              }
            });
            
            if (searchButton && searchInput) {
              searchButton.addEventListener('click', performSearch);
              searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performSearch();
              });
            }

            const printBtn = document.querySelector('.wh_print_link button');
            if (printBtn) {
              printBtn.addEventListener('click', (e) => {
                e.preventDefault();
                window.print();
              });
            }
          }

          // === INITIALIZATION ===
          function initApp() {
            debug('Initializing enhanced SPA with fixed review window system');
            
            // Create UI elements
            createConnectionStatus();
            createReviewButton();
            
            // Setup event listeners
            setupEventListeners();
            renderNavigation(navigationConfig);

            // Test connection and initialize
            testConnection().then(() => {
              const initialPageId = getPageIdFromUrl();
              if (initialPageId) {
                navigateToPage(initialPageId, false);
              } else {
                showWelcomeScreen();
              }
            });
          }

          // === APPLICATION START ===
          document.addEventListener('DOMContentLoaded', initApp);
          EOF

      # Step 13: Create enhanced default content
      - name: Create Enhanced Default Content
        run: |
          mkdir -p ./site/content

          cat > ./site/content/getting-started-with-cars.html << 'EOF'
          <h1>Getting Started With Cars</h1>
          <p>Welcome to the comprehensive automotive guide. This section covers the basics of car ownership and maintenance that every driver should know.</p>
          
          <h2>Essential Knowledge for New Car Owners</h2>
          <p>Owning a car comes with responsibilities that extend beyond just driving. Understanding your vehicle's basic systems and maintenance requirements will help ensure safe, reliable transportation and can save you money in the long run.</p>
          
          <h3>Understanding Your Dashboard</h3>
          <p>Your dashboard contains crucial warning lights and gauges that communicate your vehicle's status. Learn to recognize the check engine light, oil pressure warning, battery indicator, and temperature gauge. These indicators can alert you to potential problems before they become major repairs.</p>
          
          <h3>Basic Maintenance Schedule</h3>
          <p>Regular maintenance is the key to vehicle longevity. Most manufacturers recommend oil changes every 3,000-7,500 miles depending on your vehicle and driving conditions. Additionally, consider the following maintenance items:</p>
          <ul>
            <li>Tire rotation and pressure checks every 5,000-7,500 miles</li>
            <li>Air filter replacement every 12,000-15,000 miles</li>
            <li>Brake inspection annually or every 12,000 miles</li>
            <li>Coolant system flush every 30,000 miles</li>
            <li>Transmission service every 60,000-100,000 miles</li>
          </ul>
          
          <h3>Emergency Preparedness</h3>
          <p>Every vehicle should be equipped with emergency supplies including jumper cables, a spare tire with proper tools, emergency flares or reflectors, and a first aid kit. Knowing how to change a tire and jump-start a battery can save you time and money in emergency situations.</p>
          
          <p>Remember: When in doubt, consult your owner's manual or a qualified automotive professional. Proper maintenance and care will keep your vehicle running safely for years to come.</p>
          EOF

          cat > ./site/content/car-components.html << 'EOF'
          <h1>Essential Car Components</h1>
          <p>Understanding the major components of your vehicle helps you communicate effectively with mechanics and make informed maintenance decisions.</p>
          
          <h2>Engine and Powertrain</h2>
          <p>The powertrain is responsible for generating power and delivering it to the wheels, enabling your vehicle to move forward and backward.</p>
          
          <h3>Engine</h3>
          <p>The heart of your vehicle, the engine converts fuel into mechanical energy through controlled combustion. Modern engines are typically four-cylinder, six-cylinder, or eight-cylinder configurations, each offering different balances of power and fuel efficiency.</p>
          
          <h3>Transmission</h3>
          <p>Transfers power from the engine to the wheels while allowing gear changes. Types include manual, automatic, continuously variable (CVT), and dual-clutch transmission systems.</p>
          
          <h3>Drivetrain</h3>
          <p>Connects the transmission to the differential, transferring rotational power to rear-wheel and all-wheel drive vehicles.</p>
          
          <h3>Differential</h3>
          <p>Allows wheels to rotate at different speeds when turning while transferring power from the drivetrain to the axles.</p>
          
          <h3>Axles</h3>
          <p>Connect the wheels to the differential and support the vehicle's weight.</p>
          
          <h2>Chassis and Suspension</h2>
          <p>The foundation and support structure of the vehicle.</p>
          
          <h3>Frame/Chassis</h3>
          <p>The structural framework that supports all vehicle components. Modern passenger vehicles typically use unibody construction where the body and frame are integrated.</p>
          
          <h3>Suspension System</h3>
          <p>Connects the vehicle to its wheels, providing support, stability, and isolating the vehicle from road imperfections. Common types include MacPherson strut, double wishbone, multi-link, and solid axle configurations.</p>
          
          <h3>Steering System</h3>
          <p>Allows the driver to control the vehicle's direction. Modern vehicles typically use rack-and-pinion steering, often with power or electric assistance.</p>
          
          <h3>Braking System</h3>
          <p>Slows and stops the vehicle through friction. Components include master cylinder, brake lines, calipers, wheel cylinders, and friction materials (pads/shoes).</p>
          
          <h3>Wheels and Tires</h3>
          <p>The contact point between the vehicle and the road, providing traction and absorbing minor road imperfections.</p>
          
          <h2>Electrical and Electronic Systems</h2>
          <p>Provides power and controls for various vehicle functions.</p>
          
          <h3>Battery</h3>
          <p>Stores electrical energy for starting the engine and powering electrical systems when the engine is off.</p>
          
          <h3>Alternator</h3>
          <p>Generates electrical power while the engine is running to recharge the battery and power electrical systems.</p>
          
          <h3>Starter Motor</h3>
          <p>Initiates engine operation by turning the crankshaft.</p>
          EOF

          cat > ./site/content/basic-maintenance.html << 'EOF'
          <h1>Essential Vehicle Maintenance</h1>
          <p>Regular maintenance is crucial for vehicle safety, reliability, and longevity. Following these guidelines will help prevent costly repairs and ensure your vehicle operates at peak efficiency.</p>
          
          <h2>Engine Oil and Filter Changes</h2>
          <p>Engine oil lubricates moving parts, reduces friction, and helps regulate engine temperature. Modern vehicles typically require oil changes every 5,000-7,500 miles, though severe driving conditions may require more frequent service.</p>
          
          <h3>Oil Change Intervals by Vehicle Type:</h3>
          <ul>
            <li><strong>Conventional Oil:</strong> Every 3,000-5,000 miles</li>
            <li><strong>High-Mileage Oil:</strong> Every 5,000-7,500 miles</li>
            <li><strong>Synthetic Blend:</strong> Every 5,000-7,500 miles</li>
            <li><strong>Full Synthetic:</strong> Every 7,500-10,000 miles</li>
          </ul>
          
          <p>Always replace the oil filter with each oil change to ensure maximum filtration efficiency and engine protection.</p>
          
          <h2>Tire Care and Maintenance</h2>
          <p>Proper tire maintenance improves fuel efficiency, extends tire life, and ensures safe handling. Check tire pressure monthly using a reliable gauge, as underinflated tires can reduce fuel economy by up to 3%.</p>
          
          <h3>Tire Maintenance Schedule:</h3>
          <ul>
            <li><strong>Pressure Check:</strong> Monthly, including spare tire</li>
            <li><strong>Tire Rotation:</strong> Every 6,000-8,000 miles</li>
            <li><strong>Wheel Alignment:</strong> Annually or when uneven wear is noticed</li>
            <li><strong>Tire Replacement:</strong> When tread depth reaches 2/32 inch</li>
          </ul>
          
          <h2>Brake System Inspection</h2>
          <p>Your braking system is critical for safety and should be inspected regularly. Warning signs include squealing noises, grinding sounds, vibration during braking, or a spongy brake pedal feel.</p>
          
          <h3>Brake Component Replacement Intervals:</h3>
          <ul>
            <li><strong>Brake Pads:</strong> Every 25,000-70,000 miles (varies by driving style)</li>
            <li><strong>Brake Rotors:</strong> Every 50,000-100,000 miles</li>
            <li><strong>Brake Fluid:</strong> Every 2-3 years or 24,000-36,000 miles</li>
            <li><strong>Brake Lines:</strong> Inspect annually for corrosion or damage</li>
          </ul>
          
          <h2>Cooling System Maintenance</h2>
          <p>The cooling system prevents engine overheating by circulating coolant through the engine and radiator. Regular maintenance prevents costly engine damage from overheating.</p>
          
          <p><strong>Coolant Replacement:</strong> Every 30,000-50,000 miles or as specified in your owner's manual. Use only the coolant type recommended by your vehicle manufacturer to prevent system damage.</p>
          
          <h2>Air Filter Replacement</h2>
          <p>A clean air filter ensures proper air flow to the engine, improving performance and fuel efficiency. A dirty filter can reduce acceleration and increase fuel consumption.</p>
          
          <p><strong>Replacement Schedule:</strong> Every 12,000-15,000 miles under normal conditions, or more frequently in dusty environments.</p>
          
          <h2>Professional Inspection Recommendations</h2>
          <p>While many maintenance tasks can be performed by vehicle owners, certain inspections and services require professional expertise:</p>
          <ul>
            <li>Annual comprehensive safety inspection</li>
            <li>Transmission service every 60,000-100,000 miles</li>
            <li>Timing belt replacement (if equipped) every 60,000-105,000 miles</li>
            <li>Spark plug replacement every 30,000-100,000 miles</li>
          </ul>
          
          <p><em>Always consult your owner's manual for manufacturer-specific maintenance schedules and requirements. Severe driving conditions may require more frequent service intervals.</em></p>
          EOF

      # Step 14: Create Enhanced Index HTML
      - name: Create Enhanced Index HTML
        run: |
          cat > ./site/index.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">

            <script>
              if (location.hostname.includes('github.io')) {
                const pathSegments = location.pathname.split('/');
                if (pathSegments.length > 1) {
                  const basePath = '/' + pathSegments[1];
                  document.write('<base href="' + basePath + '/">');
                }
              }
            </script>

            <title>Enhanced Automotive Documentation with Fixed Review System</title>
            <link rel="stylesheet" href="css/style.css">
            <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🚗</text></svg>">
          </head>
          <body>
            <div class="sidebar">
              <div class="sidebar-header">
                <h2>📚 Navigation</h2>
                <div class="search-container">
                  <input type="text" id="searchInput" placeholder="Search documentation...">
                  <button id="searchButton">🔍</button>
                </div>
                <ul id="searchResults" class="search-results"></ul>
              </div>
              
              <div class="review-controls">
                <h3>🔍 Review System</h3>
                
                <div class="feedback-instructions">
                  <h4>📋 How to Review Documents:</h4>
                  <ul>
                    <li>Navigate to any document</li>
                    <li>Click "Review Mode" button (top-right)</li>
                    <li>Opens dedicated review window</li>
                    <li>Select text to leave feedback</li>
                    <li>Click feedback to scroll to text</li>
                    <li>Hover highlights for previews</li>
                  </ul>
                </div>
              </div>
              
              <div class="sidebar-nav">
                <div id="navigation"></div>
              </div>
            </div>

            <div class="main-content">
              <h1 id="content-title">Loading...</h1>
              <div id="loading" style="display:none;">Loading content...</div>
              <div id="content">
                <div class="initial-loading">
                  <p>🔄 Initializing enhanced documentation system with fixed review functionality...</p>
                </div>
              </div>
            </div>

            <div class="wh_print_link" style="position: fixed; top: 60px; right: 15px; z-index: 999;">
              <button title="Print current page" style="padding: 8px 12px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;">🖨️ Print</button>
            </div>

            <script src="js/supabase-config.js"></script>
            <script src="js/navigation-config.js"></script>
            <script src="js/content-id-map.js"></script>
            <script src="js/app.js"></script>
          </body>
          </html>
          EOF

      # Step 15: Create 404.html
      - name: Create 404 Page
        run: |
          cat > ./site/404.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Redirecting...</title>
            <script>
              sessionStorage.redirect = location.href;
              function getBasePath() {
                if (location.hostname.includes('github.io')) {
                  const pathSegments = location.pathname.split('/');
                  if (pathSegments.length > 1) return '/' + pathSegments[1];
                }
                return '';
              }
              const basePath = getBasePath();
              window.location.href = basePath + '/';
            </script>
          </head>
          <body>
            <div style="text-align: center; font-family: Arial, sans-serif; margin-top: 100px;">
              <h1>🔄 Redirecting to Enhanced Documentation System...</h1>
              <p>If you are not redirected automatically, <a href="/">click here</a>.</p>
            </div>
          </body>
          </html>
          EOF

      # Step 16: Deploy Fixed System to GitHub Pages
      - name: Deploy Fixed System to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site
          force_orphan: true

    env:
      SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}