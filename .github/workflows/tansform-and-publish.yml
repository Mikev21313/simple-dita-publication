name: DITA to SPA with Enhanced Archive System

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Set up Java (required for DITA-OT)
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Step 3: Install DITA-OT and required tools
      - name: Set up DITA-OT and XML tools
        run: |
          sudo apt-get update
          sudo apt-get install -y libxml2-utils xsltproc postgresql-client curl jq

          # Install DITA-OT
          wget https://github.com/dita-ot/dita-ot/releases/download/4.0.2/dita-ot-4.0.2.zip
          unzip dita-ot-4.0.2.zip
          chmod +x dita-ot-4.0.2/bin/dita

      # Step 4: Setup Enhanced Database Schema with Archive System
      - name: Setup Enhanced Database Schema
        run: |
          echo "🔄 Setting up enhanced database schema with archive system..."
          
          # Test connection first
          echo "Testing Supabase connection..."
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -X GET \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "apikey: ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            "https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/")
          
          if [ "$RESPONSE" -eq 200 ]; then
            echo "✅ Supabase connection successful"
          else
            echo "❌ Supabase connection failed with status: $RESPONSE"
            exit 1
          fi

          # Clear existing comments to reset system
          echo "🧹 Clearing existing comments..."
          curl -X DELETE \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "apikey: ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            "https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/comments" || echo "No existing comments to clear"

          # Clear existing archives 
          echo "🧹 Clearing existing archives..."
          curl -X DELETE \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "apikey: ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            "https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/archived_content" || echo "No existing archives to clear"

          curl -X DELETE \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "apikey: ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            "https://oiluavgeyngmkqozzmnz.supabase.co/rest/v1/archive_sessions" || echo "No existing archive sessions to clear"

          echo "✅ Database reset completed - Ready for enhanced archive system"

      # Step 5: Parse DITAMAP to generate navigation structure
      - name: Parse DITAMAP Structure
        run: |
          echo "📖 Parsing DITAMAP structure from dita-source/automotive.ditamap"

          # Create XSLT file for navigation extraction
          cat > extract-nav.xsl << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:output method="text"/>
            <xsl:template match="/">
              [<xsl:apply-templates select="//topicref[not(ancestor::topicref)]"/>]
            </xsl:template>
            <xsl:template match="topicref">
              <xsl:variable name="href" select="@href"/>
              <xsl:variable name="filename">
                <xsl:choose>
                  <xsl:when test="contains($href, '/')">
                    <xsl:value-of select="substring-after(substring-before($href, '.'), '/')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="substring-before($href, '.')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="id">
                <xsl:choose>
                  <xsl:when test="@id"><xsl:value-of select="@id"/></xsl:when>
                  <xsl:otherwise><xsl:value-of select="translate($filename, '_', '-')"/></xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="title">
                <xsl:choose>
                  <xsl:when test="@navtitle"><xsl:value-of select="@navtitle"/></xsl:when>
                  <xsl:when test="topicmeta/navtitle"><xsl:value-of select="topicmeta/navtitle"/></xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="translate(translate($id, '-', ' '), '_', ' ')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              {
                "id": "<xsl:value-of select="$id"/>",
                "title": "<xsl:value-of select="$title"/>",
                "filename": "<xsl:value-of select="$filename"/>",
                "href": "<xsl:value-of select="$href"/>"
                <xsl:if test="topicref">
                  ,"children": [<xsl:apply-templates select="topicref"/>]
                </xsl:if>
              }<xsl:if test="following-sibling::topicref">,</xsl:if>
            </xsl:template>
          </xsl:stylesheet>
          EOF

          # Apply XSLT transformation
          xsltproc extract-nav.xsl dita-source/automotive.ditamap > navigation-structure.json || echo "[]" > navigation-structure.json
          sed -i 's/\\n//g; s/\\t//g; s/  / /g' navigation-structure.json

          echo "✅ DITAMAP parsing complete"
          cat navigation-structure.json

      # Step 6: Transform DITA to HTML
      - name: Transform DITA to HTML and Prepare Images
        run: |
          ./dita-ot-4.0.2/bin/dita --input=dita-source/automotive.ditamap --format=html5 --output=./site || echo "DITA transformation completed"
          
          mkdir -p ./site/content ./site/images ./site/js ./site/css ./site/archives

          # Copy images
          find ./dita-source -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.svg" \) -exec cp -v {} ./site/images/ \; || echo "No images found"

          # Create placeholder if no images
          if [ ! "$(ls -A ./site/images 2>/dev/null)" ]; then
            echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" | base64 -d > ./site/images/placeholder.png
          fi

      # Step 7: Process HTML content for SPA
      - name: Process HTML Content
        run: |
          # Process HTML files to create SPA content
          find ./site -type f -name "*.html" | grep -v "index.html" | grep -v "404.html" | while read file; do
            if [[ "$file" == "./site/index.html" ]]; then continue; fi

            filename=$(basename "$file")
            id="${filename%.html}"
            hyphenated_id="${id//_/-}"

            # Extract content
            content=$(sed -n '/<body/,/<\/body>/p' "$file" | sed '/<body/d;/<\/body>/d' | sed '/<header/,/<\/header>/d' | sed '/<nav/,/<\/nav>/d' | sed '/<footer/,/<\/footer>/d')
            
            # Fix image paths
            content=$(echo "$content" | sed -E 's/<img([^>]*)src="[^"]*\/([^\/"]*)\.([a-zA-Z0-9]+)"/<img\1src="images\/\2.\3"/gi')
            content=$(echo "$content" | sed -E 's/<img([^>]*)src="([^\/:"]*)\.(jpg|jpeg|png|gif|svg)"/<img\1src="images\/\2.\3"/gi')

            # Get title
            title=$(grep -o "<title>.*</title>" "$file" | sed 's/<title>\(.*\)<\/title>/\1/' | head -1)
            if [ -z "$title" ]; then
              title=$(echo "$id" | tr '_-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')
            fi

            # Create content files
            echo "$content" > "./site/content/$id.html"
            if [[ "$id" != "$hyphenated_id" ]]; then
              echo "$content" > "./site/content/$hyphenated_id.html"
            fi
          done

          # Create content ID mapping
          echo "// Auto-generated content ID mapping" > ./site/js/content-id-map.js
          echo "const contentIdMap = {" >> ./site/js/content-id-map.js

          find ./site -type f -name "*.html" | grep -v "index.html" | grep -v "404.html" | while read file; do
            filename=$(basename "$file" .html)
            id="${filename//_/-}"
            original_filename="$filename"
            title=$(grep -o "<title>.*</title>" "$file" | sed 's/<title>\(.*\)<\/title>/\1/' | head -1)
            raw_content=$(cat "$file" | tr '\n' ' ' | sed 's/<[^>]*>//g' | sed 's/&nbsp;/ /g' | sed 's/  */ /g' | tr -d '\n\r')

            if grep -q "\"$id\":" ./site/js/content-id-map.js; then continue; fi

            if [ -z "$title" ]; then
              title=$(echo "$id" | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')
            fi

            title=$(echo "$title" | sed 's/"/\\"/g')
            raw_content=$(echo "$raw_content" | sed 's/"/\\"/g')

            echo "  \"$id\": { \"title\": \"$title\", \"filename\": \"$original_filename\", \"content\": \"$raw_content\" }," >> ./site/js/content-id-map.js
          done

          echo "  \"default\": { \"title\": \"Automotive Documentation\", \"filename\": \"\", \"content\": \"\" }" >> ./site/js/content-id-map.js
          echo "};" >> ./site/js/content-id-map.js

      # Step 8: Generate Navigation Configuration
      - name: Generate Navigation Configuration
        run: |
          cat > ./site/js/navigation-config.js << 'EOF'
          // Auto-generated navigation structure from DITAMAP
          const navigationConfig =
          EOF
          cat ./navigation-structure.json >> ./site/js/navigation-config.js
          echo ";" >> ./site/js/navigation-config.js

      # Step 9: Create Enhanced Supabase Configuration with Archive System
      - name: Create Enhanced Supabase Configuration
        run: |
          cat > ./site/js/supabase-config.js << 'EOF'
          // Enhanced Supabase configuration with Archive System
          const SUPABASE_URL = 'https://oiluavgeyngmkqozzmnz.supabase.co';
          const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9pbHVhdmdleW5nbWtxb3p6bW56Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg0NjIxOTgsImV4cCI6MjA2NDAzODE5OH0.zsfYoYDgArOBjP7SziUMgRQpIHhwTb-qgtw7t54MsXQ';

          class SupabaseClient {
            constructor() {
              this.baseUrl = SUPABASE_URL;
              this.headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'apikey': SUPABASE_ANON_KEY
              };
              this.connected = false;
              this.debugMode = true;
            }

            debug(message, data) {
              if (this.debugMode) {
                console.log(`[Supabase] ${message}`, data || '');
              }
            }

            async request(endpoint, options = {}) {
              const url = `${this.baseUrl}/rest/v1/${endpoint}`;
              const config = { headers: this.headers, ...options };

              this.debug(`Making request to: ${endpoint}`, { method: config.method || 'GET' });

              try {
                const response = await fetch(url, config);
                
                if (!response.ok) {
                  const errorText = await response.text();
                  this.debug(`Request failed: ${response.status} - ${errorText}`);
                  throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                this.connected = true;
                this.updateConnectionStatus(true);
                
                if (response.status === 204) {
                  this.debug('Request successful (no content)');
                  return null;
                }
                
                const text = await response.text();
                const result = text ? JSON.parse(text) : null;
                this.debug('Request successful', result);
                return result;
              } catch (error) {
                this.connected = false;
                this.updateConnectionStatus(false);
                this.debug('Request error:', error);
                throw error;
              }
            }

            updateConnectionStatus(connected) {
              const event = new CustomEvent('supabaseConnectionChange', { 
                detail: { connected } 
              });
              window.dispatchEvent(event);
            }

            async testConnection() {
              this.debug('Testing database connection...');
              try {
                await this.request('comments?limit=1');
                this.debug('Connection test successful');
                return true;
              } catch (error) {
                this.debug('Connection test failed:', error);
                return false;
              }
            }

            // === COMMENT METHODS ===
            async getComments(pageId) {
              this.debug(`Fetching comments for page: ${pageId}`);
              try {
                const comments = await this.request(
                  `comments?page_id=eq.${encodeURIComponent(pageId)}&order=created_at.desc`
                );
                this.debug(`Retrieved ${comments?.length || 0} comments`);
                return comments || [];
              } catch (error) {
                this.debug('Failed to fetch comments:', error);
                return [];
              }
            }

            async saveFeedback(feedbackData) {
              this.debug('Saving feedback:', feedbackData);
              try {
                const feedback = {
                  page_id: feedbackData.page_id,
                  comment_type: 'feedback',
                  comment_text: feedbackData.comment_text,
                  selected_text: feedbackData.selected_text || '',
                  selection_type: feedbackData.selection_type || 'text',
                  session_id: this.getSessionId(),
                  user_agent: navigator.userAgent
                };

                const response = await fetch(`${this.baseUrl}/rest/v1/comments`, {
                  method: 'POST',
                  headers: {
                    ...this.headers,
                    'Prefer': 'return=representation'
                  },
                  body: JSON.stringify(feedback)
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                const result = await response.json();
                this.debug('Feedback saved successfully:', result);
                
                // Create archive when first comment is made
                if (feedbackData.createArchive) {
                  await this.createContentArchive(feedbackData.page_id, feedbackData.contentHtml);
                }
                
                const event = new CustomEvent('feedbackSaved', { 
                  detail: { feedback: result[0] || result } 
                });
                window.dispatchEvent(event);
                
                return result;
              } catch (error) {
                this.debug('Failed to save feedback:', error);
                throw error;
              }
            }

            async deleteFeedback(feedbackId) {
              this.debug(`Deleting feedback: ${feedbackId}`);
              try {
                const response = await fetch(`${this.baseUrl}/rest/v1/comments?id=eq.${feedbackId}`, {
                  method: 'DELETE',
                  headers: this.headers
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                this.debug('Feedback deleted successfully');
                
                const event = new CustomEvent('feedbackDeleted', { 
                  detail: { feedbackId } 
                });
                window.dispatchEvent(event);

                return true;
              } catch (error) {
                this.debug('Failed to delete feedback:', error);
                throw error;
              }
            }

            async clearAllFeedback() {
              this.debug('Clearing all feedback');
              try {
                const response = await fetch(`${this.baseUrl}/rest/v1/comments`, {
                  method: 'DELETE',
                  headers: this.headers
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                this.debug('All feedback cleared successfully');

                const event = new CustomEvent('allFeedbackCleared');
                window.dispatchEvent(event);

                return true;
              } catch (error) {
                this.debug('Failed to clear feedback:', error);
                throw error;
              }
            }

            // === ARCHIVE METHODS ===
            async createContentArchive(pageId, contentHtml) {
              this.debug(`Creating archive for page: ${pageId}`);
              try {
                const archiveData = {
                  page_id: pageId,
                  content_html: contentHtml,
                  archive_version: `v${Date.now()}`,
                  resolution_status: 'active',
                  session_id: this.getSessionId()
                };

                const result = await this.request('archived_content', {
                  method: 'POST',
                  body: JSON.stringify(archiveData)
                });

                this.debug('Archive created successfully:', result);
                return result;
              } catch (error) {
                this.debug('Failed to create archive:', error);
                throw error;
              }
            }

            async getArchives(pageId) {
              this.debug(`Fetching archives for page: ${pageId}`);
              try {
                const archives = await this.request(
                  `archived_content?page_id=eq.${encodeURIComponent(pageId)}&order=created_at.desc`
                );
                this.debug(`Retrieved ${archives?.length || 0} archives`);
                return archives || [];
              } catch (error) {
                this.debug('Failed to fetch archives:', error);
                return [];
              }
            }

            async getAllArchives() {
              this.debug('Fetching all archives');
              try {
                const archives = await this.request('archived_content?order=created_at.desc');
                this.debug(`Retrieved ${archives?.length || 0} total archives`);
                return archives || [];
              } catch (error) {
                this.debug('Failed to fetch all archives:', error);
                return [];
              }
            }

            async deleteArchive(archiveId) {
              this.debug(`Deleting archive: ${archiveId}`);
              try {
                await this.request(`archived_content?id=eq.${archiveId}`, {
                  method: 'DELETE'
                });
                this.debug('Archive deleted successfully');
                return true;
              } catch (error) {
                this.debug('Failed to delete archive:', error);
                throw error;
              }
            }

            async markReviewComplete(pageId, resolutionNotes) {
              this.debug(`Marking review complete for page: ${pageId}`);
              try {
                // Update all archives for this page to resolved status
                await this.request(`archived_content?page_id=eq.${encodeURIComponent(pageId)}`, {
                  method: 'PATCH',
                  body: JSON.stringify({
                    resolution_status: 'resolved',
                    resolution_date: new Date().toISOString(),
                    reviewer_notes: resolutionNotes
                  })
                });

                this.debug('Review marked as complete');
                return true;
              } catch (error) {
                this.debug('Failed to mark review complete:', error);
                throw error;
              }
            }

            // === UTILITY METHODS ===
            getSessionId() {
              let sessionId = localStorage.getItem('reviewSessionId');
              if (!sessionId) {
                sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('reviewSessionId', sessionId);
              }
              return sessionId;
            }

            // Download archive as HTML file
            downloadArchive(archive) {
              const blob = new Blob([archive.content_html], { type: 'text/html' });
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `${archive.page_id}_${archive.archive_version}.html`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              window.URL.revokeObjectURL(url);
            }
          }

          // Initialize client
          window.supabaseClient = new SupabaseClient();
          EOF

      # Step 10: Create Enhanced CSS with New UI Layout
      - name: Create Enhanced CSS with New UI Layout
        run: |
          cat > ./site/css/style.css << 'EOF'
          /* Enhanced SPA CSS with Archive System and Repositioned UI Elements */
          * { margin: 0; padding: 0; box-sizing: border-box; }

          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6; display: flex; height: 100vh; width: 100%;
            overflow: hidden; color: #333; background-color: #f8f8f8;
          }

          .sidebar {
            width: 300px; background-color: #e0f7f7; padding: 15px;
            height: 100vh; overflow-y: auto; border-right: 1px solid #c0e0e0;
            display: flex; flex-direction: column; box-shadow: 2px 0 5px rgba(0,0,0,0.05);
          }

          .main-content {
            flex: 1; padding: 30px; height: 100vh; overflow-y: auto;
            background-color: #ffffff; position: relative;
          }

          .feedback-sidebar {
            width: 380px; background-color: #f8f9fa; padding: 20px;
            height: 100vh; overflow-y: auto; border-left: 1px solid #e0e0e0;
            display: none; flex-direction: column; box-shadow: -2px 0 5px rgba(0,0,0,0.05);
          }

          .feedback-sidebar.show { display: flex; }

          .sidebar h2 {
            font-weight: 500; margin-bottom: 15px; color: #00747a;
            border-bottom: 2px solid #80cbc4; padding-bottom: 10px; font-size: 1.4em;
          }

          .sidebar-nav { flex: 1; overflow-y: auto; margin-top: 15px; }
          .sidebar ul { list-style-type: none; padding-left: 0; margin-bottom: 5px; }
          .sidebar ul ul { padding-left: 20px; margin-top: 5px; margin-bottom: 0; }
          .sidebar li { margin-bottom: 6px; position: relative; }

          .sidebar .toggle-arrow {
            display: inline-block; width: 18px; height: 18px;
            position: absolute; left: 0; top: 4px; cursor: pointer;
            z-index: 10; color: #00747a;
          }
          .sidebar .toggle-arrow:before {
            content: "▶"; display: inline-block; font-size: 10px;
            transition: transform 0.2s;
          }
          .sidebar li.expanded > .toggle-arrow:before { transform: rotate(90deg); }
          .sidebar li.has-children > ul { display: none; }
          .sidebar li.has-children.expanded > ul { display: block; }

          .sidebar a {
            color: #00747a; text-decoration: none; display: block;
            padding: 6px 5px 6px 22px; border-radius: 4px;
            transition: background-color 0.2s, color 0.2s; cursor: pointer; font-size: 0.95em;
          }
          .sidebar a:hover { background-color: #e1f5fe; color: #006064; }
          .sidebar a.active {
            background-color: #80deea; font-weight: bold; color: #006064;
            box-shadow: inset 3px 0 0 #00acc1;
          }

          /* Review Controls Section */
          .review-controls {
            border-top: 2px solid #80cbc4; padding-top: 15px; margin-top: 15px;
            display: flex; flex-direction: column; gap: 10px;
          }
          .review-controls h3 { 
            color: #00747a; font-size: 1.1em; margin-bottom: 10px; 
          }

          .review-btn {
            padding: 8px 12px; border: 1px solid #00acc1;
            background: linear-gradient(135deg, #00acc1, #0097a7); color: white;
            border-radius: 5px; cursor: pointer; font-size: 0.9em;
            transition: all 0.3s; text-align: center;
          }
          .review-btn:hover {
            background: linear-gradient(135deg, #0097a7, #00838f);
            transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.2);
          }
          .review-btn.active {
            background: linear-gradient(135deg, #ff6f00, #e65100); border-color: #ff6f00;
          }
          .review-btn.danger {
            background: linear-gradient(135deg, #f44336, #d32f2f); border-color: #f44336;
            font-size: 0.85em; padding: 6px 10px;
          }
          .review-btn.success {
            background: linear-gradient(135deg, #4caf50, #388e3c); border-color: #4caf50;
          }

          /* Hide review controls in read-only mode */
          .review-controls .review-btn:not(#reviewToggle),
          .feedback-instructions {
            display: none;
          }
          .review-mode .review-controls .review-btn:not(#reviewToggle),
          .review-mode .feedback-instructions {
            display: block;
          }

          .feedback-instructions {
            background: #e8f5e8; border: 1px solid #c8e6c9; border-radius: 6px;
            padding: 12px; margin: 10px 0; font-size: 0.85em; color: #2e7d32;
          }
          .feedback-instructions h4 {
            margin: 0 0 8px 0; color: #1b5e20; font-size: 0.9em;
          }
          .feedback-instructions ul {
            margin: 5px 0; padding-left: 15px;
          }
          .feedback-instructions li {
            margin-bottom: 3px;
          }

          .search-container {
            margin-bottom: 15px; display: flex; gap: 5px; width: 100%;
          }
          .search-container input[type="text"] {
            flex-grow: 1; padding: 8px 10px; border: 1px solid #b0e0e6;
            border-radius: 5px; font-size: 0.9em; outline: none;
          }
          .search-container button {
            padding: 8px 10px; background-color: #00acc1; color: white;
            border: none; border-radius: 5px; cursor: pointer;
          }

          .search-results {
            list-style-type: none; padding: 0; margin-top: 15px;
            border-top: 1px solid #e0e0e0; padding-top: 10px;
            max-height: 300px; overflow-y: auto; background-color: #f5f9f9;
          }

          .main-content h1, .main-content h2, .main-content h3, .main-content h4 {
            font-weight: 500; margin-top: 1.5em; margin-bottom: 0.8em; color: #00838f;
          }
          .main-content h1 {
            font-size: 2em; border-bottom: 1px solid #e0e0e0;
            padding-bottom: 10px; margin-top: 0;
          }
          .main-content p { margin-bottom: 1em; line-height: 1.6; }
          .main-content img {
            max-width: 100%; height: auto; display: block; margin: 1em auto;
            border: 1px solid #e0e0e0; border-radius: 4px;
          }

          .welcome-screen {
            text-align: center; padding: 40px 20px; color: #00838f;
          }
          .welcome-screen h2 { margin-bottom: 20px; font-size: 2em; }

          /* Connection Status - Moved to bottom left */
          .connection-status {
            position: fixed; bottom: 15px; left: 15px; z-index: 2000;
            padding: 8px 12px; border-radius: 20px; font-size: 0.8em;
            font-weight: bold; transition: all 0.3s; cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
          }
          .connection-status.connected { 
            background: #4caf50; color: white; 
          }
          .connection-status.disconnected { 
            background: #f44336; color: white; animation: pulse 2s infinite;
          }
          .connection-status.connecting { 
            background: #ff9800; color: white; 
          }

          @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
          }

          /* Review Mode Styles */
          .review-mode .main-content { background-color: #fffbf0; }
          .review-mode .reviewable-text { 
            cursor: text; user-select: text; position: relative;
          }
          .review-mode .reviewable-text:hover {
            background-color: rgba(255, 235, 59, 0.1); border-radius: 2px;
          }

          /* Feedback Highlights */
          .review-feedback-highlight {
            background-color: #e3f2fd; border-left: 3px solid #2196f3;
            padding: 2px 4px; margin: 2px 0; border-radius: 2px; 
            cursor: pointer; position: relative;
          }

          .feedback-tooltip {
            position: absolute; top: -40px; left: 0; background: #333;
            color: white; padding: 5px 8px; border-radius: 4px; font-size: 0.8em;
            white-space: nowrap; z-index: 1000; opacity: 0; pointer-events: none;
            transition: opacity 0.2s; max-width: 200px; white-space: normal;
          }
          .feedback-tooltip:before {
            content: ''; position: absolute; top: 100%; left: 10px;
            border: 5px solid transparent; border-top-color: #333;
          }
          .review-feedback-highlight:hover .feedback-tooltip {
            opacity: 1;
          }

          /* Feedback Dialog */
          .dialog-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.5); z-index: 1999; display: none;
            animation: fadeIn 0.2s ease-out;
          }
          .dialog-overlay.show { display: block; }

          @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
          }

          .feedback-dialog {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; border: 2px solid #2c5aa0; border-radius: 8px;
            padding: 20px; width: 450px; max-width: 90vw; z-index: 2000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); display: none;
            animation: slideIn 0.3s ease-out;
          }
          .feedback-dialog.show { display: block; }

          @keyframes slideIn {
            from { transform: translate(-50%, -60%); opacity: 0; }
            to { transform: translate(-50%, -50%); opacity: 1; }
          }

          .feedback-dialog h3 { color: #2c5aa0; margin-bottom: 15px; }
          .feedback-dialog textarea {
            width: 100%; height: 100px; padding: 10px; border: 1px solid #ddd;
            border-radius: 4px; font-family: inherit; resize: vertical;
            font-size: 0.9em;
          }

          .dialog-actions {
            display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;
          }
          .dialog-btn {
            padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px;
            cursor: pointer; font-size: 0.9em; transition: all 0.2s;
          }
          .dialog-btn.primary {
            background: #2c5aa0; color: white; border-color: #2c5aa0;
          }
          .dialog-btn.primary:hover {
            background: #1e3f73; border-color: #1e3f73;
          }
          .dialog-btn.secondary { 
            background: #f5f5f5; 
          }
          .dialog-btn.secondary:hover { 
            background: #e0e0e0; 
          }

          /* Enhanced Feedback Sidebar Styles */
          .feedback-sidebar h3 {
            color: #333; margin-bottom: 20px; padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0; font-size: 1.3em; font-weight: 600;
          }

          .feedback-list {
            flex: 1; overflow-y: auto;
          }

          .feedback-group {
            background: white; border: 1px solid #e0e0e0; border-radius: 8px;
            margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden; border-left: 4px solid #2196f3;
          }

          .selected-text-header {
            background: #f8f9fa; padding: 12px 15px; border-bottom: 1px solid #e9ecef;
            font-weight: 500; color: #495057;
          }

          .selected-text-content {
            font-style: italic; background: #e9ecef; padding: 8px 12px;
            border-radius: 4px; margin-top: 8px; font-size: 0.9em;
            border-left: 3px solid #6c757d; color: #495057;
            word-wrap: break-word; overflow-wrap: break-word;
          }

          .feedback-details {
            padding: 15px;
          }

          .feedback-meta {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px; font-size: 0.85em; color: #6c757d;
          }

          .feedback-type-badge {
            padding: 3px 8px; border-radius: 12px; font-size: 0.75em; 
            font-weight: bold; text-transform: uppercase;
            background: #e3f2fd; color: #1976d2;
          }

          .feedback-text {
            margin: 10px 0; line-height: 1.5; font-size: 0.95em; color: #333;
            word-wrap: break-word; overflow-wrap: break-word;
          }

          .feedback-actions {
            display: flex; gap: 8px; margin-top: 12px; padding-top: 10px;
            border-top: 1px solid #f0f0f0;
          }

          .feedback-btn {
            padding: 5px 10px; border: 1px solid #ddd; border-radius: 4px;
            background: #f8f9fa; cursor: pointer; font-size: 0.8em;
            transition: all 0.2s; display: flex; align-items: center; gap: 4px;
          }
          .feedback-btn:hover { 
            background: #e9ecef; transform: translateY(-1px);
          }
          .feedback-btn.delete { 
            border-color: #dc3545; color: #dc3545; 
          }
          .feedback-btn.delete:hover { 
            background: #dc3545; color: white; 
          }

          /* Archive Management Styles */
          .archive-section {
            margin-top: 20px; padding-top: 15px; border-top: 2px solid #e0e0e0;
          }

          .archive-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px;
          }

          .archive-list {
            max-height: 300px; overflow-y: auto;
          }

          .archive-item {
            background: white; border: 1px solid #e0e0e0; border-radius: 6px;
            padding: 12px; margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
          }

          .archive-item-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 8px;
          }

          .archive-version {
            font-weight: bold; color: #2c5aa0; font-size: 0.9em;
          }

          .archive-status {
            padding: 2px 6px; border-radius: 10px; font-size: 0.7em;
            font-weight: bold; text-transform: uppercase;
          }

          .archive-status.active { background: #fff3cd; color: #856404; }
          .archive-status.resolved { background: #d4edda; color: #155724; }

          .archive-meta {
            font-size: 0.8em; color: #6c757d; margin-bottom: 8px;
          }

          .archive-actions {
            display: flex; gap: 6px; flex-wrap: wrap;
          }

          .archive-btn {
            padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px;
            background: #f8f9fa; cursor: pointer; font-size: 0.75em;
            transition: all 0.2s;
          }
          .archive-btn:hover { background: #e9ecef; }
          .archive-btn.view { border-color: #007bff; color: #007bff; }
          .archive-btn.view:hover { background: #007bff; color: white; }
          .archive-btn.download { border-color: #28a745; color: #28a745; }
          .archive-btn.download:hover { background: #28a745; color: white; }
          .archive-btn.delete { border-color: #dc3545; color: #dc3545; }
          .archive-btn.delete:hover { background: #dc3545; color: white; }

          /* Hide feedback toggle in read-only mode */
          .feedback-toggle {
            position: fixed; top: 60px; right: 20px; z-index: 1500;
            padding: 10px 15px; background: #2196f3; color: white; border: none;
            border-radius: 6px; cursor: pointer; font-size: 0.9em; font-weight: 500;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15); transition: all 0.2s;
            display: none;
          }
          .feedback-toggle:hover { 
            background: #1976d2; transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
          }
          .review-mode .feedback-toggle { display: block; }

          .no-feedback, .no-archives {
            text-align: center; color: #6c757d; font-style: italic; 
            padding: 40px 20px; background: white; border-radius: 8px;
            border: 1px dashed #dee2e6;
          }

          /* Review Complete Dialog */
          .review-complete-dialog {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; border: 2px solid #28a745; border-radius: 8px;
            padding: 25px; width: 500px; max-width: 90vw; z-index: 2000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); display: none;
          }
          .review-complete-dialog.show { display: block; }

          .review-complete-dialog h3 { color: #28a745; margin-bottom: 15px; }
          .review-complete-dialog textarea {
            width: 100%; height: 80px; padding: 10px; border: 1px solid #ddd;
            border-radius: 4px; font-family: inherit; resize: vertical;
            font-size: 0.9em; placeholder: 'Optional resolution notes...';
          }

          /* Responsive */
          @media (max-width: 1200px) {
            .feedback-sidebar { width: 350px; }
          }

          @media (max-width: 768px) {
            body { flex-direction: column; height: auto; }
            .sidebar { width: 100%; height: auto; max-height: 40vh; }
            .main-content { height: auto; min-height: 60vh; }
            .feedback-sidebar { 
              position: fixed; top: 0; right: -100%; width: 100%; height: 100vh;
              transition: right 0.3s ease-out; z-index: 2500;
            }
            .feedback-sidebar.show { right: 0; }
            .connection-status { position: relative; margin-bottom: 10px; }
          }
          EOF

      # Step 11: Create Enhanced SPA JavaScript with Archive System
      - name: Create Enhanced SPA JavaScript with Archive System
        run: |
          cat > ./site/js/app.js << 'EOF'
          // Enhanced SPA Application with Archive System and Streamlined Code

          // === INITIALIZATION AND STATE ===
          const DEBUG_MODE = true;
          const debug = (message, data) => {
            if (DEBUG_MODE) console.log(`[DITA-SPA] ${message}`, data || '');
          };

          // DOM Elements
          const contentEl = document.getElementById('content');
          const contentTitleEl = document.getElementById('content-title');
          const navigationEl = document.getElementById('navigation');
          const searchInput = document.getElementById('searchInput');
          const searchButton = document.getElementById('searchButton');
          const searchResultsEl = document.getElementById('searchResults');
          const reviewToggleBtn = document.getElementById('reviewToggle');
          const clearReviewBtn = document.getElementById('clearReview');

          // Application State
          const getBasePath = () => {
            if (location.hostname.includes('github.io')) {
              const pathSegments = location.pathname.split('/');
              if (pathSegments.length > 1) return '/' + pathSegments[1];
            }
            return '';
          };

          window.currentPage = null;
          window.reviewMode = false;
          window.currentSelection = null;
          window.feedback = {};
          window.archives = {};
          const basePath = getBasePath();
          let connectionStatus = 'connecting';

          // === CONNECTION MANAGEMENT ===
          function createConnectionStatus() {
            const statusEl = document.createElement('div');
            statusEl.id = 'connectionStatus';
            statusEl.className = 'connection-status connecting';
            statusEl.innerHTML = '🔄 Connecting...';
            statusEl.title = 'Click to test connection';
            statusEl.addEventListener('click', testConnection);
            document.body.appendChild(statusEl);
            debug('Connection status indicator created');
            return statusEl;
          }

          function updateConnectionStatus(connected, message) {
            let statusEl = document.getElementById('connectionStatus');
            if (!statusEl) statusEl = createConnectionStatus();
            
            if (connected) {
              statusEl.className = 'connection-status connected';
              statusEl.innerHTML = '🟢 Database Connected';
              statusEl.title = 'Database connection active - Click to refresh';
              connectionStatus = 'connected';
              debug('Connection status: Connected');
            } else {
              statusEl.className = 'connection-status disconnected';
              statusEl.innerHTML = '🔴 Database Offline';
              statusEl.title = 'Database connection failed - Click to retry';
              connectionStatus = 'disconnected';
              debug('Connection status: Disconnected');
            }
          }

          async function testConnection() {
            const statusEl = document.getElementById('connectionStatus');
            if (statusEl) {
              statusEl.className = 'connection-status connecting';
              statusEl.innerHTML = '🔄 Testing...';
            }
            
            try {
              const connected = await window.supabaseClient.testConnection();
              updateConnectionStatus(connected);
              if (connected) {
                await loadFeedbackForCurrentPage();
                await loadArchivesForCurrentPage();
              }
              return connected;
            } catch (error) {
              debug('Connection test error:', error);
              updateConnectionStatus(false);
              return false;
            }
          }

          // === FEEDBACK SIDEBAR MANAGEMENT ===
          function createFeedbackSidebar() {
            const sidebar = document.createElement('div');
            sidebar.className = 'feedback-sidebar';
            sidebar.id = 'feedbackSidebar';
            sidebar.innerHTML = `
              <h3>💬 Document Feedback & Archives</h3>
              
              <div class="feedback-list" id="feedbackList">
                <div class="no-feedback">
                  <p>No feedback yet.</p>
                  <p>Enable review mode and select text to leave feedback.</p>
                </div>
              </div>

              <div class="archive-section" id="archiveSection">
                <div class="archive-header">
                  <h4>📁 Archive Management</h4>
                  <button class="archive-btn view" onclick="openArchiveManager()">
                    📋 Manage All
                  </button>
                </div>
                <div class="archive-list" id="archiveList">
                  <div class="no-archives">
                    <p>No archived versions available.</p>
                  </div>
                </div>
              </div>
            `;
            document.body.appendChild(sidebar);
            
            // Create toggle button (hidden by default)
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'feedback-toggle';
            toggleBtn.id = 'feedbackToggle';
            toggleBtn.innerHTML = '💬 Feedback';
            toggleBtn.addEventListener('click', toggleFeedbackSidebar);
            document.body.appendChild(toggleBtn);
            
            debug('Feedback sidebar created');
            return sidebar;
          }

          function toggleFeedbackSidebar() {
            const sidebar = document.getElementById('feedbackSidebar');
            const toggleBtn = document.getElementById('feedbackToggle');
            
            if (sidebar) {
              sidebar.classList.toggle('show');
              toggleBtn.innerHTML = sidebar.classList.contains('show') ? 
                '✕ Close' : '💬 Feedback';
              
              if (sidebar.classList.contains('show')) {
                loadFeedbackForCurrentPage();
                loadArchivesForCurrentPage();
              }
            }
          }

          // === FEEDBACK MANAGEMENT ===
          async function loadFeedbackForCurrentPage() {
            if (!window.currentPage || !window.supabaseClient) {
              debug('No current page or client available for feedback loading');
              return;
            }
            
            try {
              debug(`Loading feedback for page: ${window.currentPage}`);
              const feedback = await window.supabaseClient.getComments(window.currentPage);
              
              const cleanFeedback = feedback ? feedback.filter(item => {
                return item && 
                       typeof item.comment_text === 'string' && 
                       item.comment_text.trim().length > 0 &&
                       (!item.selected_text || typeof item.selected_text === 'string');
              }) : [];
              
              debug(`Loaded ${cleanFeedback.length} feedback items`);
              window.feedback[window.currentPage] = cleanFeedback;
              displayFeedbackGrouped(cleanFeedback);
              
              if (window.reviewMode) {
                highlightFeedbackInContent(cleanFeedback);
              }
            } catch (error) {
              debug('Failed to load feedback:', error);
              displayFeedbackGrouped([]);
            }
          }

          function displayFeedbackGrouped(feedbackItems) {
            const feedbackListEl = document.getElementById('feedbackList');
            if (!feedbackListEl) return;
            
            if (!feedbackItems || feedbackItems.length === 0) {
              feedbackListEl.innerHTML = `
                <div class="no-feedback">
                  <p>No feedback for this page yet.</p>
                  <p>Enable review mode and select text to leave feedback.</p>
                </div>
              `;
              return;
            }
            
            // Group feedback by selected text
            const groupedFeedback = {};
            feedbackItems.forEach(item => {
              if (!item || !item.comment_text) return;
              
              const key = item.selected_text && item.selected_text.trim() ? 
                         item.selected_text.trim() : 'General';
              if (!groupedFeedback[key]) {
                groupedFeedback[key] = [];
              }
              groupedFeedback[key].push(item);
            });
            
            let feedbackHtml = '';
            
            Object.keys(groupedFeedback).forEach(selectedText => {
              const feedbackGroup = groupedFeedback[selectedText];
              
              feedbackHtml += `
                <div class="feedback-group">
                  ${selectedText !== 'General' ? `
                    <div class="selected-text-header">
                      📝 Selected Text:
                      <div class="selected-text-content">"${escapeHtml(selectedText)}"</div>
                    </div>
                  ` : ''}
                  
                  ${feedbackGroup.map(item => `
                    <div class="feedback-details">
                      <div class="feedback-meta">
                        <span class="feedback-type-badge">💬 feedback</span>
                        <span class="feedback-date">${formatDate(item.created_at)}</span>
                      </div>
                      <div class="feedback-text">${escapeHtml(item.comment_text)}</div>
                      <div class="feedback-actions">
                        <button class="feedback-btn delete" onclick="deleteFeedback(${item.id})">
                          🗑️ Delete
                        </button>
                      </div>
                    </div>
                  `).join('')}
                </div>
              `;
            });
            
            feedbackListEl.innerHTML = feedbackHtml;
          }

          function highlightFeedbackInContent(feedbackItems) {
            if (!feedbackItems || !window.reviewMode) return;
            
            clearReviewHighlights();
            
            feedbackItems.forEach(item => {
              if (item && item.selected_text && item.selected_text.trim()) {
                highlightTextInContent(item.selected_text, item);
              }
            });
          }

          function highlightTextInContent(selectedText, feedbackItem) {
            if (!selectedText || !contentEl || !feedbackItem) return;
            
            const walker = document.createTreeWalker(
              contentEl,
              NodeFilter.SHOW_TEXT,
              null,
              false
            );
            
            let node;
            while (node = walker.nextNode()) {
              const text = node.textContent;
              const index = text.toLowerCase().indexOf(selectedText.toLowerCase());
              
              if (index !== -1) {
                const parent = node.parentNode;
                const beforeText = text.substring(0, index);
                const actualText = text.substring(index, index + selectedText.length);
                const afterText = text.substring(index + selectedText.length);
                
                const span = document.createElement('span');
                span.className = 'review-feedback-highlight';
                span.setAttribute('data-feedback-id', feedbackItem.id);
                span.textContent = actualText;
                span.addEventListener('click', () => showFeedbackDetails(feedbackItem));
                
                const tooltip = document.createElement('div');
                tooltip.className = 'feedback-tooltip';
                tooltip.textContent = feedbackItem.comment_text.substring(0, 50) + 
                  (feedbackItem.comment_text.length > 50 ? '...' : '');
                span.appendChild(tooltip);
                
                parent.removeChild(node);
                if (beforeText) parent.appendChild(document.createTextNode(beforeText));
                parent.appendChild(span);
                if (afterText) parent.appendChild(document.createTextNode(afterText));
                
                break;
              }
            }
          }

          function showFeedbackDetails(feedbackItem) {
            if (!feedbackItem) return;
            
            const message = `FEEDBACK: ${feedbackItem.comment_text}\n\nSelected Text: "${feedbackItem.selected_text || 'General'}"\n\nCreated: ${formatDate(feedbackItem.created_at)}`;
            alert(message);
          }

          async function deleteFeedback(feedbackId) {
            if (!window.reviewMode) {
              alert('Delete is only available in Review Mode. Please enable Review Mode first.');
              return;
            }
            
            if (!confirm('Are you sure you want to delete this feedback?')) return;
            
            try {
              debug(`Deleting feedback: ${feedbackId}`);
              await window.supabaseClient.deleteFeedback(feedbackId);
              await loadFeedbackForCurrentPage();
            } catch (error) {
              debug('Delete feedback error:', error);
              alert('Failed to delete feedback. Please check your connection and try again.');
            }
          }

          // === ARCHIVE MANAGEMENT ===
          async function loadArchivesForCurrentPage() {
            if (!window.currentPage || !window.supabaseClient) {
              debug('No current page or client available for archive loading');
              return;
            }
            
            try {
              debug(`Loading archives for page: ${window.currentPage}`);
              const archives = await window.supabaseClient.getArchives(window.currentPage);
              
              debug(`Loaded ${archives.length} archive items`);
              window.archives[window.currentPage] = archives;
              displayArchiveList(archives);
            } catch (error) {
              debug('Failed to load archives:', error);
              displayArchiveList([]);
            }
          }

          function displayArchiveList(archiveItems) {
            const archiveListEl = document.getElementById('archiveList');
            if (!archiveListEl) return;
            
            if (!archiveItems || archiveItems.length === 0) {
              archiveListEl.innerHTML = `
                <div class="no-archives">
                  <p>No archived versions available.</p>
                </div>
              `;
              return;
            }
            
            let archiveHtml = '';
            
            archiveItems.forEach(archive => {
              archiveHtml += `
                <div class="archive-item">
                  <div class="archive-item-header">
                    <span class="archive-version">📄 ${archive.archive_version}</span>
                    <span class="archive-status ${archive.resolution_status}">${archive.resolution_status}</span>
                  </div>
                  <div class="archive-meta">
                    Created: ${formatDate(archive.created_at)}
                    ${archive.resolution_date ? `• Resolved: ${formatDate(archive.resolution_date)}` : ''}
                  </div>
                  <div class="archive-actions">
                    <button class="archive-btn view" onclick="viewArchive(${archive.id})">
                      👁️ View
                    </button>
                    <button class="archive-btn download" onclick="downloadArchive(${archive.id})">
                      💾 Download
                    </button>
                    <button class="archive-btn delete" onclick="deleteArchive(${archive.id})">
                      🗑️ Delete
                    </button>
                  </div>
                </div>
              `;
            });
            
            archiveListEl.innerHTML = archiveHtml;
          }

          async function viewArchive(archiveId) {
            try {
              const archives = window.archives[window.currentPage] || [];
              const archive = archives.find(a => a.id === archiveId);
              
              if (!archive) {
                alert('Archive not found');
                return;
              }
              
              debug(`Opening archive view for: ${archive.archive_version}`);
              
              // Open archive in new window
              const newWindow = window.open('', '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
              
              if (!newWindow) {
                alert('Please allow popups to view archives');
                return;
              }
              
              newWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>Archive: ${archive.archive_version} - ${window.currentPage}</title>
                  <style>
                    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
                    .archive-header { 
                      background: #f8f9fa; padding: 15px; border-bottom: 2px solid #e9ecef;
                      position: sticky; top: 0; z-index: 100;
                    }
                    .archive-info { color: #6c757d; font-size: 0.9em; }
                    .archive-content { padding: 20px; max-width: 1000px; margin: 0 auto; }
                    .archive-content img { max-width: 100%; height: auto; }
                    .close-btn { 
                      float: right; background: #dc3545; color: white; border: none;
                      padding: 8px 12px; border-radius: 4px; cursor: pointer;
                    }
                    .close-btn:hover { background: #c82333; }
                  </style>
                </head>
                <body>
                  <div class="archive-header">
                    <button class="close-btn" onclick="window.close()">✕ Close</button>
                    <h2>📄 Archive View: ${archive.archive_version}</h2>
                    <div class="archive-info">
                      Page: ${window.currentPage} | Created: ${formatDate(archive.created_at)} | Status: ${archive.resolution_status}
                    </div>
                  </div>
                  <div class="archive-content">
                    ${archive.content_html}
                  </div>
                </body>
                </html>
              `);
              
              newWindow.document.close();
              
            } catch (error) {
              debug('Failed to view archive:', error);
              alert('Failed to open archive view');
            }
          }

          async function downloadArchive(archiveId) {
            try {
              const archives = window.archives[window.currentPage] || [];
              const archive = archives.find(a => a.id === archiveId);
              
              if (!archive) {
                alert('Archive not found');
                return;
              }
              
              debug(`Downloading archive: ${archive.archive_version}`);
              window.supabaseClient.downloadArchive(archive);
            } catch (error) {
              debug('Failed to download archive:', error);
              alert('Failed to download archive');
            }
          }

          async function deleteArchive(archiveId) {
            if (!confirm('Are you sure you want to delete this archive? This cannot be undone.')) return;
            
            try {
              debug(`Deleting archive: ${archiveId}`);
              await window.supabaseClient.deleteArchive(archiveId);
              await loadArchivesForCurrentPage();
            } catch (error) {
              debug('Failed to delete archive:', error);
              alert('Failed to delete archive');
            }
          }

          function openArchiveManager() {
            alert('Archive Manager - Feature coming soon!\n\nThis will open a comprehensive view of all archived versions across all documents.');
          }

          // === REVIEW SYSTEM ===
          function initReviewSystem() {
            debug('Initializing review system');
            createFeedbackDialog();
            createReviewCompleteDialog();
            updateReviewButtons();
          }

          function createFeedbackDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'dialog-overlay';
            overlay.id = 'dialogOverlay';
            overlay.addEventListener('click', closeFeedbackDialog);

            const dialog = document.createElement('div');
            dialog.className = 'feedback-dialog';
            dialog.id = 'feedbackDialog';
            dialog.innerHTML = `
              <h3>📝 Leave Feedback</h3>
              <div style="margin: 15px 0;">
                <textarea id="feedbackText" placeholder="Enter your feedback about the selected text..."></textarea>
              </div>
              <div class="dialog-actions">
                <button class="dialog-btn secondary" onclick="closeFeedbackDialog()">Cancel</button>
                <button class="dialog-btn primary" onclick="saveFeedback()">Save Feedback</button>
              </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);
            debug('Feedback dialog created');
          }

          function createReviewCompleteDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'dialog-overlay';
            overlay.id = 'reviewCompleteOverlay';
            overlay.addEventListener('click', closeReviewCompleteDialog);

            const dialog = document.createElement('div');
            dialog.className = 'review-complete-dialog';
            dialog.id = 'reviewCompleteDialog';
            dialog.innerHTML = `
              <h3>✅ Mark Review Complete</h3>
              <p>This will mark all current feedback as resolved and create a final archive.</p>
              <div style="margin: 15px 0;">
                <textarea id="resolutionNotes" placeholder="Optional resolution notes..."></textarea>
              </div>
              <div class="dialog-actions">
                <button class="dialog-btn secondary" onclick="closeReviewCompleteDialog()">Cancel</button>
                <button class="dialog-btn success" onclick="completeReview()">Mark Complete</button>
              </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);
            debug('Review complete dialog created');
          }

          function toggleReviewMode() {
            window.reviewMode = !window.reviewMode;
            
            if (window.reviewMode) {
              document.body.classList.add('review-mode');
              initializeReviewForContent();
              debug('Review mode activated');
              
              // Show feedback sidebar
              const sidebar = document.getElementById('feedbackSidebar');
              if (sidebar && !sidebar.classList.contains('show')) {
                toggleFeedbackSidebar();
              }
            } else {
              document.body.classList.remove('review-mode');
              clearReviewHighlights();
              debug('Review mode deactivated');
            }
            
            updateReviewButtons();
          }

          function updateReviewButtons() {
            if (reviewToggleBtn) {
              reviewToggleBtn.textContent = window.reviewMode ? '✕ Exit Review' : '📝 Review Mode';
              reviewToggleBtn.classList.toggle('active', window.reviewMode);
            }
          }

          function initializeReviewForContent() {
            if (!window.reviewMode || !contentEl) return;
            
            const textElements = contentEl.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, div');
            textElements.forEach(element => {
              if (element.children.length === 0 || element.textContent.trim()) {
                element.classList.add('reviewable-text');
                element.addEventListener('mouseup', handleTextSelection);
              }
            });
            
            loadFeedbackForCurrentPage();
            loadArchivesForCurrentPage();
            
            debug('Review initialization complete for content');
          }

          function handleTextSelection(event) {
            if (!window.reviewMode) return;
            
            const selection = window.getSelection();
            if (selection.toString().trim().length === 0) return;
            
            const selectedText = selection.toString().trim();
            if (selectedText.length < 3) return;
            
            debug(`Text selected: ${selectedText}`);
            
            window.currentSelection = {
              type: 'text',
              text: selectedText,
              element: event.target
            };
            
            showFeedbackDialog();
          }

          function showFeedbackDialog() {
            const dialog = document.getElementById('feedbackDialog');
            const overlay = document.getElementById('dialogOverlay');
            
            if (dialog && overlay) {
              dialog.classList.add('show');
              overlay.classList.add('show');
              
              const selectedText = window.currentSelection?.text || '';
              if (selectedText) {
                const textArea = document.getElementById('feedbackText');
                textArea.placeholder = `Leave feedback about: "${selectedText.substring(0, 50)}${selectedText.length > 50 ? '...' : ''}"`;
              }
              
              document.getElementById('feedbackText').focus();
            }
          }

          function closeFeedbackDialog() {
            const dialog = document.getElementById('feedbackDialog');
            const overlay = document.getElementById('dialogOverlay');
            
            if (dialog && overlay) {
              dialog.classList.remove('show');
              overlay.classList.remove('show');
              document.getElementById('feedbackText').value = '';
              document.getElementById('feedbackText').placeholder = 'Enter your feedback about the selected text...';
            }
            
            window.getSelection().removeAllRanges();
            window.currentSelection = null;
          }

          function showReviewCompleteDialog() {
            const dialog = document.getElementById('reviewCompleteDialog');
            const overlay = document.getElementById('reviewCompleteOverlay');
            
            if (dialog && overlay) {
              dialog.classList.add('show');
              overlay.classList.add('show');
              document.getElementById('resolutionNotes').focus();
            }
          }

          function closeReviewCompleteDialog() {
            const dialog = document.getElementById('reviewCompleteDialog');
            const overlay = document.getElementById('reviewCompleteOverlay');
            
            if (dialog && overlay) {
              dialog.classList.remove('show');
              overlay.classList.remove('show');
              document.getElementById('resolutionNotes').value = '';
            }
          }

          async function saveFeedback() {
            if (!window.currentSelection) {
              closeFeedbackDialog();
              return;
            }
            
            const feedbackText = document.getElementById('feedbackText').value.trim();
            
            if (!feedbackText) {
              alert('Please enter your feedback.');
              return;
            }
            
            if (!window.currentPage) {
              alert('Please select a document first.');
              return;
            }
            
            try {
              // Check if this is the first feedback for this page
              const existingFeedback = window.feedback[window.currentPage] || [];
              const isFirstFeedback = existingFeedback.length === 0;
              
              const feedbackData = {
                page_id: window.currentPage,
                comment_text: feedbackText,
                selected_text: window.currentSelection.text,
                selection_type: 'text',
                createArchive: isFirstFeedback,
                contentHtml: isFirstFeedback ? contentEl.innerHTML : null
              };
              
              debug('Saving feedback:', feedbackData);
              
              const result = await window.supabaseClient.saveFeedback(feedbackData);
              debug('Feedback saved successfully:', result);
              
              const saveBtn = document.querySelector('.dialog-btn.primary');
              const originalText = saveBtn.textContent;
              saveBtn.textContent = '✓ Saved!';
              saveBtn.style.background = '#4caf50';
              
              setTimeout(() => {
                saveBtn.textContent = originalText;
                saveBtn.style.background = '';
                closeFeedbackDialog();
              }, 1000);
              
            } catch (error) {
              debug('Error saving feedback:', error);
              alert('Failed to save feedback. Please check your connection and try again.');
            }
          }

          async function completeReview() {
            const resolutionNotes = document.getElementById('resolutionNotes').value.trim();
            
            try {
              debug(`Marking review complete for page: ${window.currentPage}`);
              await window.supabaseClient.markReviewComplete(window.currentPage, resolutionNotes);
              
              // Create final archive
              await window.supabaseClient.createContentArchive(window.currentPage, contentEl.innerHTML);
              
              closeReviewCompleteDialog();
              alert('Review marked as complete! All feedback has been resolved and archived.');
              
              // Refresh data
              await loadFeedbackForCurrentPage();
              await loadArchivesForCurrentPage();
              
            } catch (error) {
              debug('Error completing review:', error);
              alert('Failed to complete review. Please check your connection and try again.');
            }
          }

          function clearReviewHighlights() {
            const highlights = document.querySelectorAll('[data-feedback-id]');
            highlights.forEach(highlight => {
              const parent = highlight.parentNode;
              if (parent) {
                parent.insertBefore(document.createTextNode(highlight.textContent), highlight);
                parent.removeChild(highlight);
              }
            });
          }

          async function promptClearReviewData() {
            if (confirm('Are you sure you want to clear ALL feedback and archives? This cannot be undone.')) {
              await clearReviewData();
            }
          }

          async function clearReviewData() {
            try {
              debug('Clearing all review data');
              await window.supabaseClient.clearAllFeedback();
              clearReviewHighlights();
              alert('All feedback and archives have been cleared successfully.');
              
              // Refresh displays
              await loadFeedbackForCurrentPage();
              await loadArchivesForCurrentPage();
            } catch (error) {
              debug('Error clearing review data:', error);
              alert(`Failed to clear review data: ${error.message}`);
            }
          }

          // === NAVIGATION SYSTEM ===
          function renderNavigation(items, parentEl = navigationEl) {
            const ul = document.createElement('ul');
            ul.setAttribute('role', 'menu');

            items.forEach(item => {
              const li = document.createElement('li');
              li.setAttribute('role', 'presentation');

              if (item.children && item.children.length > 0) {
                li.classList.add('has-children');
                const toggle = document.createElement('span');
                toggle.className = 'toggle-arrow';
                toggle.addEventListener('click', (e) => {
                  e.stopPropagation();
                  li.classList.toggle('expanded');
                });
                li.appendChild(toggle);
              }

              const a = document.createElement('a');
              a.setAttribute('role', 'menuitem');
              a.textContent = item.title;
              a.setAttribute('data-id', item.id);
              a.href = `#${item.id}`;

              a.addEventListener('click', (e) => {
                e.preventDefault();
                if (item.children && item.children.length > 0) {
                  li.classList.toggle('expanded');
                }
                navigateToPage(item.id);
                if (searchResultsEl) searchResultsEl.innerHTML = '';
                if (searchInput) searchInput.value = '';
              });

              li.appendChild(a);
              if (item.children && item.children.length > 0) {
                renderNavigation(item.children, li);
              }
              ul.appendChild(li);
            });

            parentEl.appendChild(ul);
          }

          function navigateToPage(pageId, pushState = true) {
            debug(`Navigating to page: ${pageId}`);
            
            if (!pageId) {
              showErrorContent('undefined');
              return;
            }

            updateActiveNavItem(pageId);
            expandNavigationTo(pageId);

            if (pushState) {
              history.pushState({ pageId }, '', `#${pageId}`);
            }

            document.body.classList.add('loading');
            window.currentPage = pageId;

            loadContent(pageId)
              .then(content => {
                const title = getPageTitle(pageId);
                contentTitleEl.textContent = title;
                document.title = title;
                contentEl.innerHTML = content;
                
                if (window.reviewMode) {
                  setTimeout(() => {
                    initializeReviewForContent();
                  }, 100);
                } else {
                  loadFeedbackForCurrentPage();
                  loadArchivesForCurrentPage();
                }
                
                document.body.classList.remove('loading');
                debug(`Content loaded successfully for: ${pageId}`);
              })
              .catch(error => {
                debug(`Content load error for ${pageId}:`, error);
                showErrorContent(pageId);
              });
          }

          async function loadContent(pageId) {
            const contentPath = `${basePath}/content/${pageId}.html`;
            debug(`Fetching content from: ${contentPath}`);

            try {
              const response = await fetch(contentPath);
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              return await response.text();
            } catch (error) {
              debug(`Content fetch error: ${error.message}`);
              throw error;
            }
          }

          function updateActiveNavItem(pageId) {
            const allNavItems = document.querySelectorAll('.sidebar a');
            allNavItems.forEach(item => item.classList.remove('active'));

            const activeItem = document.querySelector(`.sidebar a[data-id="${pageId}"]`);
            if (activeItem) {
              activeItem.classList.add('active');
              let parent = activeItem.parentElement;
              while (parent && !parent.classList.contains('sidebar')) {
                if (parent.classList.contains('has-children')) {
                  parent.classList.add('expanded');
                }
                parent = parent.parentElement;
              }
            }
          }

          function expandNavigationTo(pageId) {
            function findPageInNavigation(items, id, path = []) {
              for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const currentPath = [...path, item];
                if (item.id === id) return currentPath;
                if (item.children && item.children.length > 0) {
                  const result = findPageInNavigation(item.children, id, currentPath);
                  if (result) return result;
                }
              }
              return null;
            }

            const path = findPageInNavigation(navigationConfig, pageId);
            if (!path) return;

            for (let i = 0; i < path.length - 1; i++) {
              const item = path[i];
              const li = document.querySelector(`.sidebar li a[data-id="${item.id}"]`).parentElement;
              li.classList.add('expanded');
            }
          }

          function handlePopState(event) {
            const pageId = event.state?.pageId || getPageIdFromUrl() || navigationConfig[0]?.id;
            debug(`Popstate event, loading page: ${pageId}`);
            navigateToPage(pageId, false);
          }

          function getPageIdFromUrl() {
            return window.location.hash.substring(1) || null;
          }

          function getPageTitle(pageId) {
            if (window.contentIdMap && contentIdMap[pageId]) {
              return contentIdMap[pageId].title;
            }

            function findTitleInNav(items, id) {
              for (const item of items) {
                if (item.id === id) return item.title;
                if (item.children && item.children.length > 0) {
                  const title = findTitleInNav(item.children, id);
                  if (title) return title;
                }
              }
              return null;
            }

            const navTitle = findTitleInNav(navigationConfig, pageId);
            if (navTitle) return navTitle;

            return pageId.split(/-|_/).map(word =>
              word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
          }

          function showErrorContent(pageId) {
            debug(`Showing error content for: ${pageId}`);
            contentEl.innerHTML = `
              <div class="error">
                <h2>Content Not Found</h2>
                <p>The requested content "${pageId}" could not be loaded.</p>
                <p>Please select another topic from the navigation menu.</p>
              </div>
            `;
            document.body.classList.remove('loading');
          }

          function showWelcomeScreen() {
            contentTitleEl.textContent = 'Automotive Documentation';
            document.title = 'Automotive Documentation';
            contentEl.innerHTML = `
              <div class="welcome-screen">
                <h2>Welcome to Automotive Documentation</h2>
                <p>Select a topic from the navigation menu to begin.</p>
                <div style="margin-top: 30px; padding: 20px; background: #f0f8ff; border-radius: 8px; border-left: 4px solid #2196f3;">
                  <h3>💬 Enhanced Feedback & Archive System:</h3>
                  <ul style="text-align: left; margin-top: 15px;">
                    <li><strong>Review Mode:</strong> Click "Review Mode" to enable feedback features</li>
                    <li><strong>Text Selection:</strong> Select any text to leave feedback</li>
                    <li><strong>Archive System:</strong> Automatic snapshots when feedback is added</li>
                    <li><strong>Archive Viewer:</strong> View historical versions in new windows</li>
                    <li><strong>Review Resolution:</strong> Mark reviews complete with resolution notes</li>
                    <li><strong>Offline Access:</strong> Download archives for offline reference</li>
                  </ul>
                </div>
                <div style="margin-top: 20px; font-size: 0.9em; color: #666;">
                  <p>Connection Status: Check the indicator in the bottom-left corner</p>
                </div>
              </div>
            `;
            document.body.classList.remove('loading');
          }

          // === SEARCH FUNCTIONALITY ===
          function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchResultsEl.innerHTML = '';

            if (query.length < 2) {
              if (query.length > 0) {
                searchResultsEl.innerHTML = '<li><p>Please enter at least 2 characters to search.</p></li>';
              }
              return;
            }

            debug(`Performing search for: ${query}`);
            const results = [];
            
            for (const id in contentIdMap) {
              if (contentIdMap.hasOwnProperty(id) && id !== 'default') {
                const item = contentIdMap[id];
                const title = item.title.toLowerCase();
                const content = item.content ? item.content.toLowerCase() : '';

                let snippet = '';
                let matchCount = 0;

                if (title.includes(query)) {
                  matchCount += 10;
                  snippet = `Found in title: "${highlightMatch(item.title, query)}"`;
                }

                const contentMatches = content.split(query).length - 1;
                if (contentMatches > 0) {
                  matchCount += contentMatches;
                  const matchIndex = content.indexOf(query);
                  const start = Math.max(0, matchIndex - 50);
                  const end = Math.min(content.length, matchIndex + query.length + 50);
                  const context = item.content.substring(start, end);
                  snippet += (snippet ? '<br>' : '') + `...${highlightMatch(context, query)}...`;
                }

                if (matchCount > 0) {
                  results.push({ id: id, title: item.title, snippet: snippet, score: matchCount });
                }
              }
            }

            results.sort((a, b) => b.score - a.score);

            if (results.length === 0) {
              searchResultsEl.innerHTML = '<li><p>No results found for your query.</p></li>';
            } else {
              results.forEach(result => {
                const li = document.createElement('li');
                const link = document.createElement('a');
                link.href = `#${result.id}`;
                link.textContent = result.title;
                link.addEventListener('click', (e) => {
                  e.preventDefault();
                  navigateToPage(result.id);
                  searchResultsEl.innerHTML = '';
                  searchInput.value = '';
                });
                
                li.appendChild(link);
                if (result.snippet) {
                  const p = document.createElement('p');
                  p.innerHTML = result.snippet;
                  li.appendChild(p);
                }
                searchResultsEl.appendChild(li);
              });
            }
          }

          function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<span style="background: yellow;">$1</span>');
          }

          // === EVENT LISTENERS ===
          function setupEventListeners() {
            window.addEventListener('popstate', handlePopState);
            
            // Supabase event listeners
            window.addEventListener('supabaseConnectionChange', (e) => {
              updateConnectionStatus(e.detail.connected);
            });
            
            window.addEventListener('feedbackSaved', async (e) => {
              debug('Feedback saved event received');
              await loadFeedbackForCurrentPage();
              await loadArchivesForCurrentPage();
            });
            
            window.addEventListener('feedbackDeleted', async (e) => {
              debug('Feedback deleted event received');
              await loadFeedbackForCurrentPage();
            });
            
            window.addEventListener('allFeedbackCleared', async (e) => {
              debug('All feedback cleared event received');
              await loadFeedbackForCurrentPage();
              await loadArchivesForCurrentPage();
            });
            
            if (searchButton && searchInput) {
              searchButton.addEventListener('click', performSearch);
              searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performSearch();
              });
            }

            if (reviewToggleBtn) reviewToggleBtn.addEventListener('click', toggleReviewMode);
            if (clearReviewBtn) clearReviewBtn.addEventListener('click', promptClearReviewData);

            const printBtn = document.querySelector('.wh_print_link button');
            if (printBtn) {
              printBtn.addEventListener('click', (e) => {
                e.preventDefault();
                window.print();
              });
            }

            // Add complete review button
            const completeReviewBtn = document.createElement('button');
            completeReviewBtn.id = 'completeReview';
            completeReviewBtn.className = 'review-btn success';
            completeReviewBtn.textContent = '✅ Complete Review';
            completeReviewBtn.addEventListener('click', showReviewCompleteDialog);
            
            const reviewControls = document.querySelector('.review-controls');
            if (reviewControls) {
              reviewControls.insertBefore(completeReviewBtn, clearReviewBtn);
            }
          }

          // === UTILITY FUNCTIONS ===
          function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          }

          function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
          }

          // === INITIALIZATION ===
          function initApp() {
            debug('Initializing enhanced SPA with archive system');
            
            // Create UI elements
            createConnectionStatus();
            createFeedbackSidebar();
            
            // Setup event listeners
            setupEventListeners();
            renderNavigation(navigationConfig);
            initReviewSystem();

            // Test connection and initialize
            testConnection().then(() => {
              const initialPageId = getPageIdFromUrl();
              if (initialPageId) {
                navigateToPage(initialPageId, false);
              } else {
                showWelcomeScreen();
              }
            });
          }

          // === GLOBAL FUNCTION EXPORTS ===
          window.toggleReviewMode = toggleReviewMode;
          window.promptClearReviewData = promptClearReviewData;
          window.navigateToPage = navigateToPage;
          window.closeFeedbackDialog = closeFeedbackDialog;
          window.saveFeedback = saveFeedback;
          window.deleteFeedback = deleteFeedback;
          window.toggleFeedbackSidebar = toggleFeedbackSidebar;
          window.viewArchive = viewArchive;
          window.downloadArchive = downloadArchive;
          window.deleteArchive = deleteArchive;
          window.openArchiveManager = openArchiveManager;
          window.showReviewCompleteDialog = showReviewCompleteDialog;
          window.closeReviewCompleteDialog = closeReviewCompleteDialog;
          window.completeReview = completeReview;

          // === APPLICATION START ===
          document.addEventListener('DOMContentLoaded', initApp);
          EOF

      # Step 12: Create enhanced default content
      - name: Create Enhanced Default Content
        run: |
          mkdir -p ./site/content

          # Create comprehensive automotive content
          cat > ./site/content/getting-started-with-cars.html << 'EOF'
          <h1>Getting Started With Cars</h1>
          <p>Welcome to the comprehensive automotive guide. This section covers the basics of car ownership and maintenance that every driver should know.</p>
          
          <h2>Essential Knowledge for New Car Owners</h2>
          <p>Owning a car comes with responsibilities that extend beyond just driving. Understanding your vehicle's basic systems and maintenance requirements will help ensure safe, reliable transportation and can save you money in the long run.</p>
          
          <h3>Understanding Your Dashboard</h3>
          <p>Your dashboard contains crucial warning lights and gauges that communicate your vehicle's status. Learn to recognize the check engine light, oil pressure warning, battery indicator, and temperature gauge. These indicators can alert you to potential problems before they become major repairs.</p>
          
          <h3>Basic Maintenance Schedule</h3>
          <p>Regular maintenance is the key to vehicle longevity. Most manufacturers recommend oil changes every 3,000-7,500 miles depending on your vehicle and driving conditions. Additionally, consider the following maintenance items:</p>
          <ul>
            <li>Tire rotation and pressure checks every 5,000-7,500 miles</li>
            <li>Air filter replacement every 12,000-15,000 miles</li>
            <li>Brake inspection annually or every 12,000 miles</li>
            <li>Coolant system flush every 30,000 miles</li>
            <li>Transmission service every 60,000-100,000 miles</li>
          </ul>
          
          <h3>Emergency Preparedness</h3>
          <p>Every vehicle should be equipped with emergency supplies including jumper cables, a spare tire with proper tools, emergency flares or reflectors, and a first aid kit. Knowing how to change a tire and jump-start a battery can save you time and money in emergency situations.</p>
          
          <p>Remember: When in doubt, consult your owner's manual or a qualified automotive professional. Proper maintenance and care will keep your vehicle running safely for years to come.</p>
          EOF

          cat > ./site/content/car-types.html << 'EOF'
          <h1>Understanding Different Car Types</h1>
          <p>Choosing the right vehicle depends on your lifestyle, budget, and driving needs. Each car type offers distinct advantages and considerations.</p>
          
          <h2>Sedans</h2>
          <p>Sedans are traditional four-door passenger cars with a separate trunk compartment. They offer a good balance of comfort, fuel efficiency, and cargo space. Modern sedans typically seat five passengers and provide excellent highway fuel economy, often exceeding 30 MPG.</p>
          <p><strong>Best for:</strong> Daily commuting, families, business use</p>
          <p><strong>Considerations:</strong> Limited cargo space compared to SUVs, lower ground clearance</p>
          
          <h2>Sport Utility Vehicles (SUVs)</h2>
          <p>SUVs provide higher ground clearance, increased cargo capacity, and often all-wheel or four-wheel drive capability. They're built on truck platforms, offering superior towing capacity and off-road performance compared to sedans.</p>
          <p><strong>Best for:</strong> Families with active lifestyles, towing needs, adverse weather conditions</p>
          <p><strong>Considerations:</strong> Lower fuel economy, higher purchase price, increased maintenance costs</p>
          
          <h2>Hatchbacks</h2>
          <p>Hatchback vehicles feature a rear door that opens upward, providing direct access to the cargo area. This design maximizes interior space and cargo flexibility while maintaining a compact overall footprint.</p>
          <p><strong>Best for:</strong> Urban driving, parking in tight spaces, maximizing cargo versatility</p>
          <p><strong>Considerations:</strong> Road noise from cargo area, reduced rear privacy</p>
          
          <h2>Pickup Trucks</h2>
          <p>Pickup trucks combine passenger seating with an open cargo bed, offering unmatched utility for hauling materials, equipment, and recreational gear. Available in various sizes from compact to heavy-duty configurations.</p>
          <p><strong>Best for:</strong> Construction work, hauling cargo, recreational activities</p>
          <p><strong>Considerations:</strong> Poor fuel economy, challenging parking in urban areas</p>
          
          <h2>Electric Vehicles (EVs)</h2>
          <p>Electric vehicles use battery power instead of gasoline engines, offering zero direct emissions and significantly lower operating costs. Modern EVs provide competitive range and performance with rapidly expanding charging infrastructure.</p>
          <p><strong>Best for:</strong> Environmentally conscious drivers, urban commuting, reducing fuel costs</p>
          <p><strong>Considerations:</strong> Charging infrastructure limitations, higher initial purchase price</p>
          EOF

          cat > ./site/content/basic-maintenance.html << 'EOF'
          <h1>Essential Vehicle Maintenance</h1>
          <p>Regular maintenance is crucial for vehicle safety, reliability, and longevity. Following these guidelines will help prevent costly repairs and ensure your vehicle operates at peak efficiency.</p>
          
          <h2>Engine Oil and Filter Changes</h2>
          <p>Engine oil lubricates moving parts, reduces friction, and helps regulate engine temperature. Modern vehicles typically require oil changes every 5,000-7,500 miles, though severe driving conditions may require more frequent service.</p>
          
          <h3>Oil Change Intervals by Vehicle Type:</h3>
          <ul>
            <li><strong>Conventional Oil:</strong> Every 3,000-5,000 miles</li>
            <li><strong>High-Mileage Oil:</strong> Every 5,000-7,500 miles</li>
            <li><strong>Synthetic Blend:</strong> Every 5,000-7,500 miles</li>
            <li><strong>Full Synthetic:</strong> Every 7,500-10,000 miles</li>
          </ul>
          
          <p>Always replace the oil filter with each oil change to ensure maximum filtration efficiency and engine protection.</p>
          
          <h2>Tire Care and Maintenance</h2>
          <p>Proper tire maintenance improves fuel efficiency, extends tire life, and ensures safe handling. Check tire pressure monthly using a reliable gauge, as underinflated tires can reduce fuel economy by up to 3%.</p>
          
          <h3>Tire Maintenance Schedule:</h3>
          <ul>
            <li><strong>Pressure Check:</strong> Monthly, including spare tire</li>
            <li><strong>Tire Rotation:</strong> Every 6,000-8,000 miles</li>
            <li><strong>Wheel Alignment:</strong> Annually or when uneven wear is noticed</li>
            <li><strong>Tire Replacement:</strong> When tread depth reaches 2/32 inch</li>
          </ul>
          
          <h2>Brake System Inspection</h2>
          <p>Your braking system is critical for safety and should be inspected regularly. Warning signs include squealing noises, grinding sounds, vibration during braking, or a spongy brake pedal feel.</p>
          
          <h3>Brake Component Replacement Intervals:</h3>
          <ul>
            <li><strong>Brake Pads:</strong> Every 25,000-70,000 miles (varies by driving style)</li>
            <li><strong>Brake Rotors:</strong> Every 50,000-100,000 miles</li>
            <li><strong>Brake Fluid:</strong> Every 2-3 years or 24,000-36,000 miles</li>
            <li><strong>Brake Lines:</strong> Inspect annually for corrosion or damage</li>
          </ul>
          
          <h2>Cooling System Maintenance</h2>
          <p>The cooling system prevents engine overheating by circulating coolant through the engine and radiator. Regular maintenance prevents costly engine damage from overheating.</p>
          
          <p><strong>Coolant Replacement:</strong> Every 30,000-50,000 miles or as specified in your owner's manual. Use only the coolant type recommended by your vehicle manufacturer to prevent system damage.</p>
          
          <h2>Air Filter Replacement</h2>
          <p>A clean air filter ensures proper air flow to the engine, improving performance and fuel efficiency. A dirty filter can reduce acceleration and increase fuel consumption.</p>
          
          <p><strong>Replacement Schedule:</strong> Every 12,000-15,000 miles under normal conditions, or more frequently in dusty environments.</p>
          
          <h2>Professional Inspection Recommendations</h2>
          <p>While many maintenance tasks can be performed by vehicle owners, certain inspections and services require professional expertise:</p>
          <ul>
            <li>Annual comprehensive safety inspection</li>
            <li>Transmission service every 60,000-100,000 miles</li>
            <li>Timing belt replacement (if equipped) every 60,000-105,000 miles</li>
            <li>Spark plug replacement every 30,000-100,000 miles</li>
          </ul>
          
          <p><em>Always consult your owner's manual for manufacturer-specific maintenance schedules and requirements. Severe driving conditions may require more frequent service intervals.</em></p>
          EOF

      # Step 13: Create Enhanced Index HTML
      - name: Create Enhanced Index HTML
        run: |
          cat > ./site/index.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">

            <script>
              if (location.hostname.includes('github.io')) {
                const pathSegments = location.pathname.split('/');
                if (pathSegments.length > 1) {
                  const basePath = '/' + pathSegments[1];
                  document.write('<base href="' + basePath + '/">');
                }
              }
            </script>

            <title>Enhanced Automotive Documentation with Archive System</title>
            <link rel="stylesheet" href="css/style.css">
            <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🚗</text></svg>">
          </head>
          <body>
            <div class="sidebar">
              <div class="sidebar-header">
                <h2>📚 Navigation</h2>
                <div class="search-container">
                  <input type="text" id="searchInput" placeholder="Search documentation...">
                  <button id="searchButton">🔍</button>
                </div>
                <ul id="searchResults" class="search-results"></ul>
              </div>
              
              <div class="review-controls">
                <h3>💬 Feedback & Archive System</h3>
                <div class="review-mode-toggle">
                  <button id="reviewToggle" class="review-btn">📝 Review Mode</button>
                </div>
                
                <div class="feedback-instructions">
                  <h4>📝 Review Mode Features:</h4>
                  <ul>
                    <li>Select text to leave feedback</li>
                    <li>Automatic content archiving</li>
                    <li>View archived versions</li>
                    <li>Mark reviews as complete</li>
                    <li>Download offline copies</li>
                  </ul>
                </div>
                
                <button id="completeReview" class="review-btn success">✅ Complete Review</button>
                <button id="clearReview" class="review-btn danger">🗑️ Clear All</button>
              </div>
              
              <div class="sidebar-nav">
                <div id="navigation"></div>
              </div>
            </div>

            <div class="main-content">
              <h1 id="content-title">Loading...</h1>
              <div id="loading" style="display:none;">Loading content...</div>
              <div id="content">
                <div class="initial-loading">
                  <p>🔄 Initializing enhanced documentation system with archive capabilities...</p>
                </div>
              </div>
            </div>

            <div class="wh_print_link" style="position: fixed; top: 15px; right: 15px; z-index: 999;">
              <button title="Print current page" style="padding: 8px 12px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;">🖨️ Print</button>
            </div>

            <script src="js/supabase-config.js"></script>
            <script src="js/navigation-config.js"></script>
            <script src="js/content-id-map.js"></script>
            <script src="js/app.js"></script>
          </body>
          </html>
          EOF

      # Step 14: Create 404.html
      - name: Create 404 Page
        run: |
          cat > ./site/404.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Redirecting...</title>
            <script>
              sessionStorage.redirect = location.href;
              function getBasePath() {
                if (location.hostname.includes('github.io')) {
                  const pathSegments = location.pathname.split('/');
                  if (pathSegments.length > 1) return '/' + pathSegments[1];
                }
                return '';
              }
              const basePath = getBasePath();
              window.location.href = basePath + '/';
            </script>
          </head>
          <body>
            <div style="text-align: center; font-family: Arial, sans-serif; margin-top: 100px;">
              <h1>🔄 Redirecting to Enhanced Documentation System...</h1>
              <p>If you are not redirected automatically, <a href="/">click here</a>.</p>
            </div>
          </body>
          </html>
          EOF

      # Step 15: Deploy to GitHub Pages
      - name: Deploy Enhanced System to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site
          force_orphan: true

    env:
      SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}