name: DITA to SPA Transformation with Enhanced Staticman Comments Review System

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Set up Java (required for DITA-OT)
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Step 3: Create Staticman Configuration
      - name: Create Staticman Configuration
        run: |
          cat > staticman.yml << 'EOF'
          # Staticman configuration for document review comments
          comments:
            allowedFields: [
              "name", 
              "email", 
              "url", 
              "message", 
              "pageId", 
              "commentType", 
              "selectedText", 
              "selectionType", 
              "position", 
              "imageSrc", 
              "imageAlt", 
              "uploadedImages",
              "timestamp",
              "resolved"
            ]
            branch: "main"
            commitMessage: "Add review comment from {fields.name}"
            filename: "comment-{@timestamp}"
            format: "json"
            transforms:
              email: md5
            moderation: false
            name: "[username]"
            path: "_data/comments/{options.pageId}"
            requiredFields: ["name", "message", "pageId"]
            generatedFields:
              date:
                type: "date"
                options:
                  format: "iso8601"
              id:
                type: "date"
                options:
                  format: "timestamp"
          EOF

      # Step 4: Install DITA-OT and required tools
      - name: Set up DITA-OT and XML tools
        run: |
          sudo apt-get update
          sudo apt-get install -y libxml2-utils xsltproc
          wget https://github.com/dita-ot/dita-ot/releases/download/4.0.2/dita-ot-4.0.2.zip
          unzip dita-ot-4.0.2.zip
          chmod +x dita-ot-4.0.2/bin/dita

      # Step 5: Parse DITAMAP structure
      - name: Parse DITAMAP Structure
        run: |
          echo "Parsing DITAMAP structure from dita-source/automotive.ditamap"
          cat > extract-nav.xsl << 'XSLEOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:output method="text"/>
            <xsl:template match="/">
              [
                <xsl:apply-templates select="//topicref[not(ancestor::topicref)]"/>
              ]
            </xsl:template>
            <xsl:template match="topicref">
              <xsl:variable name="href" select="@href"/>
              <xsl:variable name="filename">
                <xsl:choose>
                  <xsl:when test="contains($href, '/')">
                    <xsl:value-of select="substring-after(substring-before($href, '.'), '/')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="substring-before($href, '.')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="id">
                <xsl:choose>
                  <xsl:when test="@id"><xsl:value-of select="@id"/></xsl:when>
                  <xsl:otherwise><xsl:value-of select="translate($filename, '_', '-')"/></xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="title">
                <xsl:choose>
                  <xsl:when test="@navtitle"><xsl:value-of select="@navtitle"/></xsl:when>
                  <xsl:when test="topicmeta/navtitle"><xsl:value-of select="topicmeta/navtitle"/></xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="translate(translate($id, '-', ' '), '_', ' ')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              {
                "id": "<xsl:value-of select="$id"/>",
                "title": "<xsl:value-of select="$title"/>",
                "filename": "<xsl:value-of select="$filename"/>",
                "href": "<xsl:value-of select="$href"/>"
                <xsl:if test="topicref">
                  ,
                  "children": [
                    <xsl:apply-templates select="topicref"/>
                  ]
                </xsl:if>
              }<xsl:if test="following-sibling::topicref">,</xsl:if>
            </xsl:template>
          </xsl:stylesheet>
          XSLEOF
          
          xsltproc extract-nav.xsl dita-source/automotive.ditamap > ./navigation-structure.json
          sed -i 's/\\n//g; s/\\t//g; s/\\"//g; s/\\//g; s/  / /g' ./navigation-structure.json

      # Step 6: Transform DITA to HTML
      - name: Transform DITA to HTML and Prepare Images
        run: |
          ./dita-ot-4.0.2/bin/dita --input=dita-source/automotive.ditamap --format=html5 --output=./site
          mkdir -p ./site/content ./site/images ./site/_data/comments
          
          find ./dita-source -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.svg" \) -exec cp -v {} ./site/images/ \;
          
          if [ ! "$(ls -A ./site/images 2>/dev/null)" ]; then
            echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" | base64 -d > ./site/images/test.png
          fi

      # Step 7: Process HTML Content
      - name: Process HTML Content
        run: |
          mkdir -p ./site/content ./site/js
          
          find ./site -type f -name "*.html" | grep -v "index.html" | grep -v "404.html" | while read file; do
            if [[ "$file" == "./site/index.html" ]]; then
              continue
            fi
            
            filename=$(basename "$file")
            id="${filename%.html}"
            
            content=$(sed -n '/<body/,/<\/body>/p' "$file" | sed '/<body/d;/<\/body>/d' | sed '/<header/,/<\/header>/d' | sed '/<nav/,/<\/nav>/d' | sed '/<footer/,/<\/footer>/d')
            content=$(echo "$content" | sed -E 's/<img([^>]*)src="[^"]*\/([^\/"]*)\.([a-zA-Z0-9]+)"/<img\1src="images\/\2.\3"/gi')
            
            echo "$content" > "./site/content/$id.html"
          done
          
          echo "const contentIdMap = {" > ./site/js/content-id-map.js
          find ./site -type f -name "*.html" | grep -v "index.html" | grep -v "404.html" | while read file; do
            filename=$(basename "$file" .html)
            title=$(grep -o "<title>.*</title>" "$file" | sed 's/<title>\(.*\)<\/title>/\1/' | head -1)
            raw_content=$(cat "$file" | tr '\n' ' ' | sed 's/<[^>]*>//g' | sed 's/&nbsp;/ /g' | sed 's/  */ /g')
            
            if [ -z "$title" ]; then
              title=$(echo "$filename" | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')
            fi
            
            title=$(echo "$title" | sed 's/"/\\"/g')
            raw_content=$(echo "$raw_content" | sed 's/"/\\"/g')
            
            echo "  \"$filename\": { \"title\": \"$title\", \"filename\": \"$filename\", \"content\": \"$raw_content\" }," >> ./site/js/content-id-map.js
          done
          echo "};" >> ./site/js/content-id-map.js

      # Step 8: Create JavaScript Files
      - name: Create JavaScript Files
        run: |
          mkdir -p ./site/js
          
          # Navigation config
          echo "const navigationConfig =" > ./site/js/navigation-config.js
          cat ./navigation-structure.json >> ./site/js/navigation-config.js
          echo ";" >> ./site/js/navigation-config.js
          
          # Staticman config
          REPO_OWNER="${GITHUB_REPOSITORY%/*}"
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          
          cat > ./site/js/staticman-config.js << 'JSEOF'
          window.staticmanConfig = {
            endpoint: 'https://api.staticman.net/v3/entry/github/REPO_OWNER/REPO_NAME/BRANCH_NAME/comments',
            repository: 'REPO_OWNER/REPO_NAME',
            branch: 'BRANCH_NAME',
            enabled: true,
            troubleshooting: {
              setupUrl: 'https://api.staticman.net/v3/connect/github/REPO_OWNER/REPO_NAME',
              docsUrl: 'https://staticman.net/docs/'
            }
          };
          JSEOF
          
          sed -i "s/REPO_OWNER/$REPO_OWNER/g" ./site/js/staticman-config.js
          sed -i "s/REPO_NAME/$REPO_NAME/g" ./site/js/staticman-config.js
          sed -i "s/BRANCH_NAME/$BRANCH_NAME/g" ./site/js/staticman-config.js

      # Step 9: Create Comments Loader
      - name: Create Comments Loader
        run: |
          cat > ./site/js/comments-loader.js << 'JSEOF'
          window.staticmanComments = {};
          window.localComments = {};

          async function loadStaticmanComments() {
            try {
              const repoComments = window.preloadedComments || {};
              const localData = localStorage.getItem('staticman-comments');
              const localComments = localData ? JSON.parse(localData) : {};
              
              const allComments = {};
              Object.keys(repoComments).forEach(pageId => {
                allComments[pageId] = repoComments[pageId] || [];
              });
              
              Object.keys(localComments).forEach(pageId => {
                if (!allComments[pageId]) {
                  allComments[pageId] = [];
                }
                allComments[pageId] = [
                  ...allComments[pageId],
                  ...localComments[pageId].map(comment => ({
                    ...comment,
                    local: true,
                    synced: false
                  }))
                ];
              });
              
              return allComments;
            } catch (error) {
              console.log('Error loading comments:', error);
              return {};
            }
          }

          function saveCommentToLocal(comment) {
            try {
              const existing = localStorage.getItem('staticman-comments');
              const comments = existing ? JSON.parse(existing) : {};
              
              if (!comments[comment.pageId]) {
                comments[comment.pageId] = [];
              }
              
              comments[comment.pageId].push(comment);
              localStorage.setItem('staticman-comments', JSON.stringify(comments));
              return true;
            } catch (error) {
              console.error('Failed to save comment locally:', error);
              return false;
            }
          }

          function exportLocalComments() {
            try {
              const localData = localStorage.getItem('staticman-comments');
              if (!localData) {
                alert('No local comments found to export.');
                return;
              }
              
              const blob = new Blob([localData], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'staticman-comments-' + new Date().toISOString().split('T')[0] + '.json';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            } catch (error) {
              alert('Failed to export comments: ' + error.message);
            }
          }

          function clearLocalComments() {
            if (confirm('This will permanently delete all locally stored comments. Continue?')) {
              localStorage.removeItem('staticman-comments');
              alert('Local comments cleared.');
              location.reload();
            }
          }

          document.addEventListener('DOMContentLoaded', async () => {
            window.staticmanComments = await loadStaticmanComments();
            window.localComments = JSON.parse(localStorage.getItem('staticman-comments') || '{}');
          });

          window.saveCommentToLocal = saveCommentToLocal;
          window.exportLocalComments = exportLocalComments;
          window.clearLocalComments = clearLocalComments;
          window.loadStaticmanComments = loadStaticmanComments;
          JSEOF
          
          echo "window.preloadedComments = {};" > ./site/js/preloaded-comments.js

      # Step 10: Create CSS
      - name: Create Enhanced CSS
        run: |
          mkdir -p ./site/css
          cat > ./site/css/style.css << 'CSSEOF'
          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }

          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            display: flex;
            height: 100vh;
            overflow: hidden;
            color: #333;
            background-color: #f8f8f8;
          }

          .sidebar {
            width: 280px;
            background-color: #e0f7f7;
            padding: 15px;
            height: 100vh;
            overflow-y: auto;
            border-right: 1px solid #c0e0e0;
            display: flex;
            flex-direction: column;
          }

          .main-content {
            flex: 1;
            padding: 30px;
            height: 100vh;
            overflow-y: auto;
            background-color: #ffffff;
            position: relative;
            transition: margin-right 0.3s ease;
          }

          .staticman-status {
            background: linear-gradient(135deg, #4caf50, #388e3c);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
            text-align: center;
            cursor: default;
          }

          .staticman-status.offline {
            background: linear-gradient(135deg, #ff9800, #f57c00);
          }

          .staticman-status.error {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            cursor: pointer;
          }

          .staticman-status.connecting {
            background: linear-gradient(135deg, #2196f3, #1976d2);
          }

          .staticman-status::before {
            content: '●';
            margin-right: 6px;
            animation: pulse 2s infinite;
          }

          @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
          }

          .comments-side-cart {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: #ffffff;
            border-left: 2px solid #2c5aa0;
            box-shadow: -3px 0 15px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: right 0.3s ease;
          }

          .comments-side-cart.open {
            right: 0;
          }

          .cart-header {
            background: linear-gradient(135deg, #2c5aa0, #1e3a8a);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
          }

          .cart-close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
          }

          .sidebar h2 {
            color: #00747a;
            border-bottom: 2px solid #80cbc4;
            padding-bottom: 10px;
            margin-bottom: 15px;
          }

          .review-controls {
            border-top: 2px solid #80cbc4;
            padding-top: 15px;
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
          }

          .review-btn {
            padding: 8px 12px;
            border: 1px solid #00acc1;
            background: linear-gradient(135deg, #00acc1, #0097a7);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
          }

          .review-btn:hover {
            background: linear-gradient(135deg, #0097a7, #00838f);
            transform: translateY(-1px);
          }

          .review-btn.active {
            background: linear-gradient(135deg, #ff6f00, #e65100);
          }

          .search-container {
            margin-bottom: 15px;
            display: flex;
            gap: 5px;
          }

          .search-container input {
            flex: 1;
            padding: 8px;
            border: 1px solid #b0e0e6;
            border-radius: 5px;
          }

          .search-container button {
            padding: 8px 12px;
            background-color: #00acc1;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
          }

          .sidebar ul {
            list-style: none;
            padding: 0;
          }

          .sidebar a {
            color: #00747a;
            text-decoration: none;
            display: block;
            padding: 6px;
            border-radius: 4px;
            transition: background-color 0.2s;
          }

          .sidebar a:hover {
            background-color: #e1f5fe;
          }

          .sidebar a.active {
            background-color: #80deea;
            font-weight: bold;
          }

          .main-content h1 {
            color: #00838f;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 10px;
            margin-bottom: 20px;
          }

          .welcome-screen {
            text-align: center;
            padding: 40px 20px;
            color: #00838f;
          }

          .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.3);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
          }

          .loading-overlay.show {
            display: flex;
          }

          .comment-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #2c5aa0;
            border-radius: 8px;
            padding: 20px;
            width: 450px;
            max-width: 90vw;
            z-index: 2000;
            display: none;
          }

          .comment-dialog.show {
            display: block;
          }

          .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.5);
            z-index: 1999;
            display: none;
          }

          .dialog-overlay.show {
            display: block;
          }

          @media (max-width: 768px) {
            body {
              flex-direction: column;
              height: auto;
            }

            .sidebar {
              width: 100%;
              height: auto;
              max-height: 40vh;
            }

            .main-content {
              height: auto;
              min-height: 60vh;
            }
          }
          CSSEOF

      # Step 11: Create Main App JavaScript
      - name: Create Main App JavaScript
        run: |
          cat > ./site/js/app.js << 'APPEOF'
          const contentEl = document.getElementById('content');
          const contentTitleEl = document.getElementById('content-title');
          const navigationEl = document.getElementById('navigation');
          const searchInput = document.getElementById('searchInput');
          const searchButton = document.getElementById('searchButton');
          const searchResultsEl = document.getElementById('searchResults');

          const reviewToggleBtn = document.getElementById('reviewToggle');
          const startReviewBtn = document.getElementById('startReview');
          const clearReviewBtn = document.getElementById('clearReview');

          const getBasePath = () => {
            if (location.hostname.includes('github.io')) {
              const pathSegments = location.pathname.split('/');
              if (pathSegments.length > 1) {
                return '/' + pathSegments[1];
              }
            }
            return '';
          };

          window.currentPage = null;
          window.reviewMode = false;
          window.staticmanComments = {};
          window.pendingComments = [];
          const basePath = getBasePath();

          class StaticmanIntegration {
            constructor() {
              this.endpoint = window.staticmanConfig?.endpoint || null;
              this.enabled = window.staticmanConfig?.enabled || false;
              this.status = 'offline';
              this.fallbackMode = false;
              this.checkConnection();
            }

            async checkConnection() {
              if (!this.endpoint) {
                this.setStatus('error', 'No endpoint configured');
                this.enableFallbackMode();
                return;
              }

              try {
                this.setStatus('connecting', 'Testing connection...');
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(this.endpoint, {
                  method: 'HEAD',
                  signal: controller.signal,
                  mode: 'cors'
                });
                clearTimeout(timeoutId);
                
                if (response.ok || response.status === 404 || response.status === 405) {
                  this.setStatus('online', 'Connected to Staticman');
                  this.fallbackMode = false;
                } else {
                  throw new Error('Service returned ' + response.status);
                }
              } catch (error) {
                this.setStatus('error', 'Connection failed: ' + error.message);
                this.enableFallbackMode();
              }
            }

            enableFallbackMode() {
              this.fallbackMode = true;
              this.setStatus('offline', 'Using local storage fallback');
            }

            setStatus(status, message) {
              this.status = status;
              this.updateStatusUI(status, message);
            }

            updateStatusUI(status, message) {
              let statusEl = document.getElementById('staticmanStatus');
              if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'staticmanStatus';
                statusEl.className = 'staticman-status';
                
                const reviewControls = document.querySelector('.review-controls');
                if (reviewControls) {
                  reviewControls.insertBefore(statusEl, reviewControls.firstChild);
                }
              }

              statusEl.className = 'staticman-status ' + status;
              statusEl.textContent = message || this.getStatusMessage(status);
              
              if (status === 'error') {
                statusEl.style.cursor = 'pointer';
                statusEl.onclick = () => this.showTroubleshootingInfo();
              }
            }

            showTroubleshootingInfo() {
              alert('Staticman connection failed. Comments will be saved locally and can be exported.');
            }

            getStatusMessage(status) {
              const messages = {
                'online': 'Staticman Connected',
                'offline': 'Fallback Mode (Local)',
                'connecting': 'Connecting...',
                'error': 'Connection Error (Click for help)'
              };
              return messages[status] || 'Unknown Status';
            }

            async submitComment(commentData) {
              if (this.fallbackMode || !this.endpoint) {
                return this.saveCommentLocally(commentData);
              }

              try {
                const response = await fetch(this.endpoint, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ fields: commentData })
                });

                if (!response.ok) {
                  throw new Error('HTTP ' + response.status);
                }

                this.setStatus('online', 'Comment submitted successfully');
                return { success: true };
              } catch (error) {
                return this.saveCommentLocally(commentData, error.message);
              }
            }

            saveCommentLocally(commentData, errorMessage = null) {
              try {
                commentData.local = true;
                commentData.synced = false;
                if (errorMessage) commentData.error = errorMessage;
                
                const saved = window.saveCommentToLocal(commentData);
                if (saved) {
                  window.pendingComments.push(commentData);
                  return { success: true, local: true, comment: commentData };
                }
                throw new Error('Failed to save locally');
              } catch (error) {
                throw error;
              }
            }

            async loadCommentsForPage(pageId) {
              try {
                const allComments = await window.loadStaticmanComments();
                return allComments[pageId] || [];
              } catch (error) {
                return [];
              }
            }
          }

          const staticman = new StaticmanIntegration();

          function initApp() {
            renderNavigation(navigationConfig);
            window.addEventListener('popstate', handlePopState);
            
            if (searchButton && searchInput) {
              searchButton.addEventListener('click', performSearch);
              searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performSearch();
              });
            }

            if (reviewToggleBtn) reviewToggleBtn.addEventListener('click', toggleReviewMode);
            if (startReviewBtn) startReviewBtn.addEventListener('click', startReviewSession);
            if (clearReviewBtn) clearReviewBtn.addEventListener('click', promptClearReviewData);

            initReviewSystem();
            const initialPageId = getPageIdFromUrl();
            if (initialPageId) {
              navigateToPage(initialPageId, false);
            } else {
              showWelcomeScreen();
            }
          }

          function initReviewSystem() {
            createHoverTooltip();
            createCommentDialog();
            createCommentsSideCart();
            createLoadingOverlay();
            updateReviewButtons();
          }

          function createLoadingOverlay() {
            const overlay = document.createElement('div');
            overlay.className = 'loading-overlay';
            overlay.id = 'loadingOverlay';
            overlay.innerHTML = '<div class="loading-spinner"><div>Processing comment...</div></div>';
            document.body.appendChild(overlay);
          }

          function createCommentsSideCart() {
            const sideCart = document.createElement('div');
            sideCart.className = 'comments-side-cart';
            sideCart.id = 'commentsSideCart';
            sideCart.innerHTML = '<div class="cart-header"><h3>Comments</h3><button class="cart-close-btn" onclick="closeCommentsSideCart()">✕</button></div><div class="cart-content"><div id="commentsList">No comments yet</div></div>';
            document.body.appendChild(sideCart);
          }

          function createHoverTooltip() {
            const tooltip = document.createElement('div');
            tooltip.className = 'comment-tooltip';
            tooltip.id = 'commentTooltip';
            document.body.appendChild(tooltip);
          }

          function createCommentDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'dialog-overlay';
            overlay.id = 'dialogOverlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'comment-dialog';
            dialog.id = 'commentDialog';
            dialog.innerHTML = '<h3>Add Comment</h3><input type="text" id="commentName" placeholder="Your name"><textarea id="commentText" placeholder="Your comment"></textarea><div><button onclick="closeCommentDialog()">Cancel</button><button onclick="saveComment()">Save</button></div>';
            
            document.body.appendChild(overlay);
            document.body.appendChild(dialog);
          }

          function showWelcomeScreen() {
            contentTitleEl.textContent = 'Documentation';
            document.title = 'Documentation';
            contentEl.innerHTML = '<div class="welcome-screen"><h2>Welcome to Enhanced Documentation</h2><p>Select a topic from the navigation menu or use the search bar.</p></div>';
          }

          function toggleReviewMode() {
            window.reviewMode = !window.reviewMode;
            document.body.classList.toggle('review-mode', window.reviewMode);
            updateReviewButtons();
          }

          function startReviewSession() {
            if (!window.currentPage) {
              alert('Please select a document to review first.');
              return;
            }
            if (!window.reviewMode) toggleReviewMode();
            alert('Review session started. You can now select text to add comments.');
          }

          function promptClearReviewData() {
            if (confirm('Clear all local comments?')) {
              window.clearLocalComments();
            }
          }

          function updateReviewButtons() {
            if (reviewToggleBtn) {
              reviewToggleBtn.textContent = window.reviewMode ? 'Exit Review' : 'Review Mode';
              reviewToggleBtn.classList.toggle('active', window.reviewMode);
            }
          }

          function openCommentsSideCart() {
            document.getElementById('commentsSideCart').classList.add('open');
          }

          function closeCommentsSideCart() {
            document.getElementById('commentsSideCart').classList.remove('open');
          }

          function showCommentDialog() {
            document.getElementById('commentDialog').classList.add('show');
            document.getElementById('dialogOverlay').classList.add('show');
          }

          function closeCommentDialog() {
            document.getElementById('commentDialog').classList.remove('show');
            document.getElementById('dialogOverlay').classList.remove('show');
          }

          function saveComment() {
            const name = document.getElementById('commentName').value;
            const text = document.getElementById('commentText').value;
            if (!name || !text) {
              alert('Please fill in all fields');
              return;
            }
            
            const commentData = {
              id: 'comment_' + Date.now(),
              name: name,
              message: text,
              pageId: window.currentPage,
              timestamp: new Date().toISOString()
            };
            
            staticman.submitComment(commentData).then(() => {
              alert('Comment saved!');
              closeCommentDialog();
            }).catch(error => {
              alert('Error saving comment: ' + error.message);
            });
          }

          function renderNavigation(items, parentEl = navigationEl) {
            const ul = document.createElement('ul');
            items.forEach(item => {
              const li = document.createElement('li');
              const a = document.createElement('a');
              a.textContent = item.title;
              a.href = '#' + item.id;
              a.addEventListener('click', (e) => {
                e.preventDefault();
                navigateToPage(item.id);
              });
              li.appendChild(a);
              if (item.children) {
                renderNavigation(item.children, li);
              }
              ul.appendChild(li);
            });
            parentEl.appendChild(ul);
          }

          function navigateToPage(pageId, pushState = true) {
            if (!pageId) return;
            
            updateActiveNavItem(pageId);
            if (pushState) {
              history.pushState({ pageId }, '', '#' + pageId);
            }
            
            window.currentPage = pageId;
            loadContent(pageId).then(content => {
              const title = getPageTitle(pageId);
              contentTitleEl.textContent = title;
              document.title = title;
              contentEl.innerHTML = content;
            }).catch(() => {
              showErrorContent(pageId);
            });
          }

          function loadContent(pageId) {
            const contentPath = basePath + '/content/' + pageId + '.html';
            return fetch(contentPath).then(response => {
              if (!response.ok) throw new Error('Content not found');
              return response.text();
            });
          }

          function updateActiveNavItem(pageId) {
            document.querySelectorAll('.sidebar a').forEach(a => a.classList.remove('active'));
            const activeItem = document.querySelector('.sidebar a[href="#' + pageId + '"]');
            if (activeItem) activeItem.classList.add('active');
          }

          function handlePopState(event) {
            const pageId = event.state?.pageId || getPageIdFromUrl();
            if (pageId) navigateToPage(pageId, false);
          }

          function getPageIdFromUrl() {
            return window.location.hash.substring(1) || null;
          }

          function getPageTitle(pageId) {
            if (window.contentIdMap && contentIdMap[pageId]) {
              return contentIdMap[pageId].title;
            }
            return pageId.split('-').map(word => 
              word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
          }

          function showErrorContent(pageId) {
            contentEl.innerHTML = '<div class="error"><h2>Content Not Found</h2><p>The requested content "' + pageId + '" could not be loaded.</p></div>';
          }

          function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchResultsEl.innerHTML = '';
            
            if (query.length < 2) return;
            
            const results = [];
            for (const id in contentIdMap) {
              if (contentIdMap[id].title.toLowerCase().includes(query) || 
                  contentIdMap[id].content.toLowerCase().includes(query)) {
                results.push({ id, title: contentIdMap[id].title });
              }
            }
            
            results.forEach(result => {
              const li = document.createElement('li');
              const a = document.createElement('a');
              a.textContent = result.title;
              a.href = '#' + result.id;
              a.addEventListener('click', (e) => {
                e.preventDefault();
                navigateToPage(result.id);
                searchResultsEl.innerHTML = '';
                searchInput.value = '';
              });
              li.appendChild(a);
              searchResultsEl.appendChild(li);
            });
          }

          window.openCommentsSideCart = openCommentsSideCart;
          window.closeCommentsSideCart = closeCommentsSideCart;
          window.showCommentDialog = showCommentDialog;
          window.closeCommentDialog = closeCommentDialog;
          window.saveComment = saveComment;

          document.addEventListener('DOMContentLoaded', initApp);
          APPEOF

      # Step 12: Create HTML files
      - name: Create HTML Files
        run: |
          cat > ./site/index.html << 'HTMLEOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Documentation - Enhanced with Smart Comments</title>
            <link rel="stylesheet" href="css/style.css">
          </head>
          <body>
            <div class="sidebar">
              <div class="sidebar-header">
                <h2>Navigation</h2>
                <div class="search-container">
                  <input type="text" id="searchInput" placeholder="Search...">
                  <button id="searchButton">Search</button>
                </div>
                <ul id="searchResults" class="search-results"></ul>
              </div>
              
              <div class="review-controls">
                <h3>Smart Review System</h3>
                <div class="review-mode-toggle">
                  <button id="reviewToggle" class="review-btn">Review Mode</button>
                </div>
                <button id="startReview" class="review-btn secondary">Start Review</button>
                <button id="clearReview" class="review-btn danger">Clear Local</button>
              </div>
              
              <div class="sidebar-nav">
                <div id="navigation"></div>
              </div>
            </div>

            <div class="main-content">
              <h1 id="content-title">Loading...</h1>
              <div id="content">
                <div class="initial-loading">
                  <p>Initializing enhanced documentation viewer...</p>
                </div>
              </div>
            </div>

            <script src="js/staticman-config.js"></script>
            <script src="js/preloaded-comments.js"></script>
            <script src="js/comments-loader.js"></script>
            <script src="js/navigation-config.js"></script>
            <script src="js/content-id-map.js"></script>
            <script src="js/app.js"></script>
          </body>
          </html>
          HTMLEOF
          
          cat > ./site/404.html << 'HTML404EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <title>Redirecting...</title>
            <script>
              const basePath = location.hostname.includes('github.io') && location.pathname.split('/').length > 1 
                ? '/' + location.pathname.split('/')[1] : '';
              window.location.href = basePath + '/';
            </script>
          </head>
          <body>
            <p>Redirecting...</p>
          </body>
          </html>
          HTML404EOF
          
          cp staticman.yml ./site/

      # Step 13: Create default content
      - name: Create Default Content
        run: |
          mkdir -p ./site/content
          
          for id in automotive-information basic-maintenance major-vehicle-components; do
            title=$(echo "$id" | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')
            cat > "./site/content/$id.html" << CONTENTEOF
          <h1>${title}</h1>
          <p>This section contains information about ${title}.</p>
          <p>Use the navigation menu to explore topics within this section.</p>
          <p><strong>Review Mode:</strong> Use the review controls to enable collaborative commenting.</p>
          <p><strong>Smart Comments System:</strong> Comments are automatically synchronized or stored locally.</p>
          CONTENTEOF
          done

      # Step 14: Deploy to GitHub Pages
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site
          force_orphan: true